{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#mimosa-integrated-assessment-model-for-cost-benefit-analysis","title":"MIMOSA: Integrated Assessment Model for Cost-Benefit Analysis","text":"<p>Documentation  Installation  Running </p> Warning <p>This documentation is still under construction and will be updated regularly.</p> <p>MIMOSA is an Integrated Assessment Model (IAM) part of the IMAGE family, with 26 regions covering the whole world. It is a relatively simple Cost-Benefit IAM that still covers the relevant technological and socio-economic dynamics. The climate impacts are calculated using state-of-the-art COACCH damage functions, and the mitigation costs have been directly calibrated to the IPCC AR6 WGIII database.</p> <p>MIMOSA is being developed at the Copernicus Institute of Sustainable Development at Utrecht University, and is part of the IMAGE modelling framework.</p> <p> </p>"},{"location":"#general","title":"General","text":"<p>The model is written in the Python optimisation package Pyomo. It uses IPOPT (an open-source large-scale nonlinear optimisation suite) to solve the model.</p> <p> Schematic overview of the MIMOSA model. Adapted from [1].</p>"},{"location":"#how-to-cite","title":"How to cite","text":"<p>When using MIMOSA, please cite [1] (global version) and [2] (regional version).</p>"},{"location":"#references","title":"References","text":"<p>[1]  van der Wijst, KI., Hof, A.F. &amp; van Vuuren, D.P. On the optimality of 2\u00b0C targets and a decomposition of uncertainty. Nature Communications 12, 2575 (2021). https://doi.org/10.1038/s41467-021-22826-5</p> <p>[2]  van der Wijst, KI., Bosello, F., Dasgupta, S. et al. New damage curves and multimodel analysis suggest lower optimal temperature. Nature Climate Change 13, 434\u2013441 (2023). https://doi.org/10.1038/s41558-023-01636-1</p>"},{"location":"#what-does-mimosa-stand-for","title":"What does MIMOSA stand for?","text":"<p>MIMOSA: Mathematical Integrated Model for Optimal and Stylised Assessment</p>"},{"location":"installation/","title":"Installing MIMOSA","text":"<p>MIMOSA is written in Python, can be installed using <code>pip</code>: <pre><code>pip install mimosa\n</code></pre></p> <p>If you don't have Python installed yet, we highly recommend to use Anaconda to install python. </p>"},{"location":"installation/#installing-the-optimisation-engine-ipopt","title":"Installing the optimisation engine IPOPT","text":"<p>Since MIMOSA is an optimisation model, an optimisation engine needs to be specified. We use the open-source optimisation engine IPOPT, which can be installed as a <code>conda</code> package.</p> On WindowsOn MacOSOn Linux <pre><code>conda install -c conda-forge ipopt=3.11.1\n</code></pre> <pre><code>conda install -c idaes-pse -c conda-forge idaes-pse\n\nconda install -c conda-forge ipopt\n</code></pre> <pre><code>conda install -c conda-forge ipopt\n</code></pre> <p>Once IPOPT is installed, you can now solve your MIMOSA runs (see Running MIMOSA): <pre><code>from mimosa import MIMOSA, load_params\n\nparams = load_params()\n\nmodel1 = MIMOSA(params)\nmodel1.solve()\nmodel1.save(\"run1\")\n</code></pre></p> Fixing the error <code>IPOPT not found</code> on Windows <p>Sometimes, installing IPOPT with conda fails on Windows. To fix it, go to https://github.com/coin-or/Ipopt/releases and download the latest win64-version. Unzip the files. A subfolder <code>bin</code> should contain the file <code>ipopt.exe</code>. The next step is to add this folder to your PATH environment: Windows &gt; Edit the system environment variables &gt; Environment variables... &gt; Select \"Path\" and click Edit... &gt; Click New and browse to the folder you just unzipped. Make sure to select the <code>bin</code> subfolder as this folder contains the file <code>ipopt.exe</code>.</p> <ol> <li>Once you've downloaded the zip file of the latest win64-version on the coin website (currently <code>Ipopt-3.14.15-win64-msvs2019-md.zip</code>), unzip this file to folder of your choice. In the unzipped folder, there should be a <code>bin</code> folder.</li> <li>The next step is to tell Windows to look for IPOPT in this <code>bin</code> directory. This is achieved by adding the relevant folder to the environment path of Windows. Click on Start (or press the Win key), type <code>environment</code> and press Enter. This should open the dialog <code>Edit the system environment variables</code>.</li> <li>Click on <code>Environment variables</code>, select <code>Path</code> and click edit.</li> <li>Here, you can add the folder with the IPOPT bin folder. Click on New and add the folder you unzipped IPOPT in, making sure to select the sub-folder <code>bin</code>:</li> <li>You can test if everything works by opening an Anaconda Prompt and typing <code>ipopt</code>. It should show something like this:</li> </ol>"},{"location":"installation/#using-the-neos-server","title":"Using the NEOS server","text":"<p>The MIMOSA runs can also easily be sent to the NEOS server (https://neos-server.org) for remote optimisation. This way, the installation of IPOPT is not required. This can be useful if you don't want to use your own computer to do the runs. However, this is typically much slower than installing IPOPT locally.</p> <p>First, on the NEOS website, sign up for a free account. You can then run MIMOSA with NEOS enabled by simply providing it with the email address you used to sign up for NEOS:</p> <pre><code>from mimosa import MIMOSA, load_params\n\nparams = load_params()\n\nmodel1 = MIMOSA(params)\nmodel1.solve(use_neos=True, neos_email=\"your.email@email.com\")\nmodel1.save(\"run1\")\n</code></pre> <p>Depending on the MIMOSA parameters chosen and on how busy the NEOS server is, running the model might take a while (typically a couple of minutes).</p> <p>Next: Running MIMOSA </p>"},{"location":"parameters/","title":"Parameter reference","text":"SSP <p>SSP, used for population, baseline GDP and baseline emissions</p> <ul> <li> <p>Type: enum</p> </li> <li> <p>Default: SSP2</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Allowed values:</p> <ul> <li>SSP1</li> <li>SSP2</li> <li>SSP3</li> <li>SSP4</li> <li>SSP5</li> </ul> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"SSP\"] = \"SSP2\"\nmodel = MIMOSA(params)\n</code></pre> regionstype <p> </p> <p>Name of the region definition. Used in the mapping of the regional parameters.</p> <ul> <li> <p>Type: enum</p> </li> <li> <p>Default: IMAGE26</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Allowed values:</p> <ul> <li>IMAGE26</li> <li>SSP5</li> <li>World</li> </ul> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"regionstype\"] = \"IMAGE26\"\nmodel = MIMOSA(params)\n</code></pre> regionsmappings <p> </p> <p>List of region types and their conversion tables. Only used for regional parameters, not for aggregating or disaggregating variables or other output.</p> <ul> <li> <p>Type: list</p> </li> <li> <p>Default: [{'regionstype1': 'IMAGE26', 'regionstype2': 'COACCH', 'conversiontable': 'inputdata/regions/IMAGE26_COACCH.csv'}, {'regionstype1': 'IMAGE26', 'regionstype2': 'ADRICE2010', 'conversiontable': 'inputdata/regions/IMAGE26_ADRICE2010.csv'}, {'regionstype1': 'IMAGE26', 'regionstype2': 'ADRICE2012', 'conversiontable': 'inputdata/regions/IMAGE26_ADRICE2012.csv'}]</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"regionsmappings\"] = [{'regionstype1': 'IMAGE26', 'regionstype2': 'COACCH', 'conversiontable': 'inputdata/regions/IMAGE26_COACCH.csv'}, {'regionstype1': 'IMAGE26', 'regionstype2': 'ADRICE2010', 'conversiontable': 'inputdata/regions/IMAGE26_ADRICE2010.csv'}, {'regionstype1': 'IMAGE26', 'regionstype2': 'ADRICE2012', 'conversiontable': 'inputdata/regions/IMAGE26_ADRICE2012.csv'}]\nmodel = MIMOSA(params)\n</code></pre> regional_parameter_files <p> </p> <p>Dictionary of regional parameter files. If the regionstype of the file is different from the regionstype of the model, the file is converted using the <code>regionsmappings</code> parameter.</p> <ul> <li> <p>Type: dict</p> </li> <li> <p>Default: {'economics': {'filename': 'inputdata/regionalparams/economics.csv', 'regionstype': 'IMAGE26'}, 'MAC': {'filename': 'inputdata/regionalparams/mac.csv', 'regionstype': 'IMAGE26'}, 'COACCH': {'filename': 'inputdata/regionalparams/COACCH.csv', 'regionstype': 'COACCH'}}</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"regional_parameter_files\"] = {'economics': {'filename': 'inputdata/regionalparams/economics.csv', 'regionstype': 'IMAGE26'}, 'MAC': {'filename': 'inputdata/regionalparams/mac.csv', 'regionstype': 'IMAGE26'}, 'COACCH': {'filename': 'inputdata/regionalparams/COACCH.csv', 'regionstype': 'COACCH'}}\nmodel = MIMOSA(params)\n</code></pre> regions <p> </p> <p>Dictionary of all regions with optional dictionaries defining, optionally, manual values for certain parameters for that specific region.</p> <ul> <li> <p>Type: dict</p> </li> <li> <p>Default: {'CAN': None, 'USA': None, 'MEX': None, 'RCAM': None, 'BRA': None, 'RSAM': None, 'NAF': None, 'WAF': None, 'EAF': None, 'SAF': None, 'WEU': None, 'CEU': None, 'TUR': None, 'UKR': None, 'STAN': None, 'RUS': None, 'ME': None, 'INDIA': None, 'KOR': None, 'CHN': None, 'SEAS': None, 'INDO': None, 'JAP': None, 'OCE': None, 'RSAS': None, 'RSAF': None}</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"regions\"] = {'CAN': None, 'USA': None, 'MEX': None, 'RCAM': None, 'BRA': None, 'RSAM': None, 'NAF': None, 'WAF': None, 'EAF': None, 'SAF': None, 'WEU': None, 'CEU': None, 'TUR': None, 'UKR': None, 'STAN': None, 'RUS': None, 'ME': None, 'INDIA': None, 'KOR': None, 'CHN': None, 'SEAS': None, 'INDO': None, 'JAP': None, 'OCE': None, 'RSAS': None, 'RSAF': None}\nmodel = MIMOSA(params)\n</code></pre> <p></p>"},{"location":"parameters/#time_1","title":"time","text":"start <p>Year in which the model starts</p> <ul> <li> <p>Type: int</p> </li> <li> <p>Default: 2020</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 1900</p> </li> <li> <p>Max: 2100</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"time\"][\"start\"] = 2020\nmodel = MIMOSA(params)\n</code></pre> end <p> </p> <p>Last year of the model run</p> <ul> <li> <p>Type: int</p> </li> <li> <p>Default: 2150</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 1901</p> </li> <li> <p>Max: 2300</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"time\"][\"end\"] = 2150\nmodel = MIMOSA(params)\n</code></pre> dt <p> </p> <p>Timestep in years</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 5</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0.5</p> </li> <li> <p>Max: 20</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"time\"][\"dt\"] = 5\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#economics_1","title":"economics","text":"PRTP <p>Pure rate of time preference</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 0.015</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0</p> </li> <li> <p>Max: 0.2</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"PRTP\"] = 0.015\nmodel = MIMOSA(params)\n</code></pre> elasmu <p> </p> <p>Elasticity of marginal utility</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 1.001</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0.1</p> </li> <li> <p>Max: 10</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"elasmu\"] = 1.001\nmodel = MIMOSA(params)\n</code></pre> inequal_aversion <p> </p> <p>Parameter of inequality aversion. Should be between 0 and <code>elasmu</code>. Only used when welfare_module='inequal_aversion_general'</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 0.5</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0.0</p> </li> <li> <p>Max: 3</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"inequal_aversion\"] = 0.5\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#economics-gdp","title":"economics &gt; GDP","text":"alpha <p>Output elasticity of capital</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 0.3</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0</p> </li> <li> <p>Max: 1</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"GDP\"][\"alpha\"] = 0.3\nmodel = MIMOSA(params)\n</code></pre> depreciation of capital <p> </p> <p>Yearly depreciation rate of capital stock</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 0.05</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0</p> </li> <li> <p>Max: inf</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"GDP\"][\"depreciation of capital\"] = 0.05\nmodel = MIMOSA(params)\n</code></pre> savings rate <p> </p> <p>Fraction of GDP used for investments</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 0.21</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0</p> </li> <li> <p>Max: 1</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"GDP\"][\"savings rate\"] = 0.21\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#economics-mac","title":"economics &gt; MAC","text":"beta <p>Power factor of the MAC curve</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 3</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0.01</p> </li> <li> <p>Max: 10</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"MAC\"][\"beta\"] = 3\nmodel = MIMOSA(params)\n</code></pre> gamma <p> </p> <p>Calibration level of the MAC (carbon price for 100% reduction)</p> <ul> <li> <p>Type: quantity</p> </li> <li> <p>Default: 2601 USD2005/tCO2</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Unit: currency_unit/emissionsrate_unit</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"MAC\"][\"gamma\"] = \"2601 USD2005/tCO2\"\nmodel = MIMOSA(params)\n</code></pre> LBD_rate <p> </p> <p>Learning by doing rate: reduction in marginal mitigation costs for doubling cumulative mitigation capacity. Empirical studies show values between 0.65 (high learning) and 0.95 (low learning)</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 0.82</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0.1</p> </li> <li> <p>Max: 1</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"MAC\"][\"LBD_rate\"] = 0.82\nmodel = MIMOSA(params)\n</code></pre> LBD_scaling <p> </p> <p>Scaling factor for learning by doing to transform the units of cumulative mitigation in relative terms (compared to baseline emissions in t=0). Only used for calibration, and should not be used to change the amount of LBD (for this, use the economics &gt; MAC &gt; rho parameter)</p> <ul> <li> <p>Type: quantity</p> </li> <li> <p>Default: 40 GtCO2</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Unit: emissions_unit</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"MAC\"][\"LBD_scaling\"] = \"40 GtCO2\"\nmodel = MIMOSA(params)\n</code></pre> LOT_rate <p> </p> <p>Learning rate of exogenous learning (learning over time). By default, there is no exogenous learning assumed, as all the technological learning happens endogenously (learning by doing).</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 0</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0</p> </li> <li> <p>Max: inf</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"MAC\"][\"LOT_rate\"] = 0\nmodel = MIMOSA(params)\n</code></pre> regional calibration factor <p> </p> <p>Column from mac.csv to be used for the regional MACs. The MACs are calibrated from TIMER SSP2-RCP2.6 MACs at a given year and a given carbon price / abatement level.</p> <ul> <li> <p>Type: enum</p> </li> <li> <p>Default: kappa_rel_abatement_0.75_2050</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Allowed values:</p> <ul> <li>kappa_carbonprice_200_2030</li> <li>kappa_carbonprice_200_2050</li> <li>kappa_carbonprice_200_2070</li> <li>kappa_carbonprice_200_2100</li> <li>kappa_carbonprice_300_2030</li> <li>kappa_carbonprice_300_2050</li> <li>kappa_carbonprice_300_2070</li> <li>kappa_carbonprice_300_2100</li> <li>kappa_carbonprice_500_2030</li> <li>kappa_carbonprice_500_2050</li> <li>kappa_carbonprice_500_2070</li> <li>kappa_carbonprice_500_2100</li> <li>kappa_carbonprice_1000_2030</li> <li>kappa_carbonprice_1000_2050</li> <li>kappa_carbonprice_1000_2070</li> <li>kappa_carbonprice_1000_2100</li> <li>kappa_rel_abatement_0.25_2030</li> <li>kappa_rel_abatement_0.25_2050</li> <li>kappa_rel_abatement_0.25_2070</li> <li>kappa_rel_abatement_0.25_2100</li> <li>kappa_rel_abatement_0.4_2030</li> <li>kappa_rel_abatement_0.4_2050</li> <li>kappa_rel_abatement_0.4_2070</li> <li>kappa_rel_abatement_0.4_2100</li> <li>kappa_rel_abatement_0.5_2050</li> <li>kappa_rel_abatement_0.5_2070</li> <li>kappa_rel_abatement_0.5_2100</li> <li>kappa_rel_abatement_0.75_2050</li> <li>kappa_rel_abatement_0.75_2070</li> <li>kappa_rel_abatement_0.75_2100</li> </ul> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"MAC\"][\"regional calibration factor\"] = \"kappa_rel_abatement_0.75_2050\"\nmodel = MIMOSA(params)\n</code></pre> rel_mitigation_costs_min_level <p> </p> <p>Minimum level of mitigation costs (rel to GDP). By default, this is 0: no negative abatement costs are allowed. For certain burden sharing regimes, this value can become negative to allow certain (small) financial transfers.</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 0</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: -2</p> </li> <li> <p>Max: 0</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"MAC\"][\"rel_mitigation_costs_min_level\"] = 0\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#economics-emission-trade","title":"economics &gt; emission trade","text":"min rel payment level <p>Which percentage of the area under the MAC of a region should it pay itself (minimum)? If false: no limt</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: False</p> </li> <li> <p>Can be false: True</p> </li> <li> <p>Min: 0</p> </li> <li> <p>Max: 1</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"emission trade\"][\"min rel payment level\"] = False\nmodel = MIMOSA(params)\n</code></pre> max rel payment level <p> </p> <p>Which percentage of the area under the MAC of a region should it pay itself (maximum)? If false: no limit</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: False</p> </li> <li> <p>Can be false: True</p> </li> <li> <p>Min: 1</p> </li> <li> <p>Max: inf</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"emission trade\"][\"max rel payment level\"] = False\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#economics-damages","title":"economics &gt; damages","text":"percentage reversible <p>Factor of damages that are reversible</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 1</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0</p> </li> <li> <p>Max: 1</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"damages\"][\"percentage reversible\"] = 1\nmodel = MIMOSA(params)\n</code></pre> scale factor <p> </p> <p>Manual scaling factor to increase or decrease damages</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 1</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: -inf</p> </li> <li> <p>Max: inf</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"damages\"][\"scale factor\"] = 1\nmodel = MIMOSA(params)\n</code></pre> ignore damages <p> </p> <p>Flag to not take into account the damages in the GDP (but damages are calculated)</p> <ul> <li> <p>Type: bool</p> </li> <li> <p>Default: False</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"damages\"][\"ignore damages\"] = False\nmodel = MIMOSA(params)\n</code></pre> quantile <p> </p> <p>Damage quantile (Only used for COACCH)</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 0.5</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0.025</p> </li> <li> <p>Max: 0.975</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"damages\"][\"quantile\"] = 0.5\nmodel = MIMOSA(params)\n</code></pre> coacch_slr_withadapt <p> </p> <p>Flag to use the SLR-with-Adapation damage functions (Only used for COACCH)</p> <ul> <li> <p>Type: bool</p> </li> <li> <p>Default: True</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"damages\"][\"coacch_slr_withadapt\"] = True\nmodel = MIMOSA(params)\n</code></pre> coacch_combined_slr_nonslr_damages <p> </p> <p>If true, do not model SLR damages separately from non-SLR, but use the combined damage functions (Only used for COACCH)</p> <ul> <li> <p>Type: bool</p> </li> <li> <p>Default: False</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"damages\"][\"coacch_combined_slr_nonslr_damages\"] = False\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#emissions_1","title":"emissions","text":"carbonbudget <p>Value of the carbon budget. Example: \"800 GtCO2\" (the unit is important). If set to False, no carbon budget is imposed: this is cost-benefit mode. Default: False.</p> <ul> <li> <p>Type: quantity</p> </li> <li> <p>Default: False</p> </li> <li> <p>Can be false: True</p> </li> <li> <p>Unit: emissions_unit</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"emissions\"][\"carbonbudget\"] = False\nmodel = MIMOSA(params)\n</code></pre> global min level <p> </p> <p>Limit on the emission level (globally), mostly used for negative emissions. Can also be false, then no limit is imposed</p> <ul> <li> <p>Type: quantity</p> </li> <li> <p>Default: -20 GtCO2/yr</p> </li> <li> <p>Can be false: True</p> </li> <li> <p>Unit: emissionsrate_unit</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"emissions\"][\"global min level\"] = \"-20 GtCO2/yr\"\nmodel = MIMOSA(params)\n</code></pre> regional min level <p> </p> <p>Limit on the emission level (per region), mostly used for negative emissions. Can also be false, then no limit is imposed</p> <ul> <li> <p>Type: quantity</p> </li> <li> <p>Default: -10 GtCO2/yr</p> </li> <li> <p>Can be false: True</p> </li> <li> <p>Unit: emissionsrate_unit</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"emissions\"][\"regional min level\"] = \"-10 GtCO2/yr\"\nmodel = MIMOSA(params)\n</code></pre> not positive after budget year <p> </p> <p>If true, impose net-zero emissions after budget year (2100)</p> <ul> <li> <p>Type: bool</p> </li> <li> <p>Default: True</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"emissions\"][\"not positive after budget year\"] = True\nmodel = MIMOSA(params)\n</code></pre> non increasing emissions after 2100 <p> </p> <p>If true, the regional emissions after 2100 are not allowed to climb.</p> <ul> <li> <p>Type: bool</p> </li> <li> <p>Default: True</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"emissions\"][\"non increasing emissions after 2100\"] = True\nmodel = MIMOSA(params)\n</code></pre> baseline carbon intensity <p> </p> <p>If true, use baseline carbon intensity to calculate baseline emissions. If false, the SSP baseline emissions are used, regardless of lower GDP.</p> <ul> <li> <p>Type: bool</p> </li> <li> <p>Default: True</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"emissions\"][\"baseline carbon intensity\"] = True\nmodel = MIMOSA(params)\n</code></pre> cumulative_emissions_trapz <p> </p> <p>If true, calculate cumulative emissions using trapezoidal interpolation. If false, cum. emissions are simply cum_emissions[t-1] + dt * cum_emissions[t]. This is less accurate, but better for numerical stability. For small dt the  approximation is usually still acceptable.</p> <ul> <li> <p>Type: bool</p> </li> <li> <p>Default: True</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"emissions\"][\"cumulative_emissions_trapz\"] = True\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#emissions-inertia","title":"emissions &gt; inertia","text":"global <p>Maximum reduction speed, in % of initial emissions (should be negative) Can also be false, then no inertia limit is imposed</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: False</p> </li> <li> <p>Can be false: True</p> </li> <li> <p>Min: -inf</p> </li> <li> <p>Max: 0</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"emissions\"][\"inertia\"][\"global\"] = False\nmodel = MIMOSA(params)\n</code></pre> regional <p> </p> <p>Maximum reduction speed, in % of initial emissions (should be negative) Can also be false, then no inertia limit is imposed</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: -0.05</p> </li> <li> <p>Can be false: True</p> </li> <li> <p>Min: -inf</p> </li> <li> <p>Max: 0</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"emissions\"][\"inertia\"][\"regional\"] = -0.05\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#effort-sharing","title":"effort sharing","text":"regime <p>Type of effort sharing to be used</p> <ul> <li> <p>Type: enum</p> </li> <li> <p>Default: noregime</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Allowed values:</p> <ul> <li>noregime</li> <li>equal_mitigation_costs</li> <li>equal_total_costs</li> <li>per_cap_convergence</li> </ul> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"effort sharing\"][\"regime\"] = \"noregime\"\nmodel = MIMOSA(params)\n</code></pre> percapconv_year <p> </p> <p>Year of convergence to per capita emission allowance  (only used when effort sharing - regime is per_cap_convergence) Can also be false, then always use grandfathering</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 2050</p> </li> <li> <p>Can be false: True</p> </li> <li> <p>Min: 2020</p> </li> <li> <p>Max: 2200</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"effort sharing\"][\"percapconv_year\"] = 2050\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#temperature_1","title":"temperature","text":"initial <p>Temperature in initial year of model run (2020 by default).</p> <ul> <li> <p>Type: quantity</p> </li> <li> <p>Default: 1.16 delta_degC</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Unit: temperature_unit</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"temperature\"][\"initial\"] = \"1.16 delta_degC\"\nmodel = MIMOSA(params)\n</code></pre> TCRE <p> </p> <p>Transient Climate Response to CO2 Emissions</p> <ul> <li> <p>Type: quantity</p> </li> <li> <p>Default: 0.62 delta_degC/(TtCO2)</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Unit: (temperature_unit)/(emissions_unit)</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"temperature\"][\"TCRE\"] = \"0.62 delta_degC/(TtCO2)\"\nmodel = MIMOSA(params)\n</code></pre> target <p> </p> <p>Temperature target in 2100 (and beyond). Can also be false, then no temperature target is imposed</p> <ul> <li> <p>Type: quantity</p> </li> <li> <p>Default: False</p> </li> <li> <p>Can be false: True</p> </li> <li> <p>Unit: temperature_unit</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"temperature\"][\"target\"] = False\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#model_1","title":"model","text":"damage module <p>Damage module to be used</p> <ul> <li> <p>Type: enum</p> </li> <li> <p>Default: COACCH</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Allowed values:</p> <ul> <li>COACCH</li> <li>nodamage</li> </ul> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"model\"][\"damage module\"] = \"COACCH\"\nmodel = MIMOSA(params)\n</code></pre> emissiontrade module <p> </p> <p>Emission trade module to be used</p> <ul> <li> <p>Type: enum</p> </li> <li> <p>Default: notrade</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Allowed values:</p> <ul> <li>notrade</li> <li>globalcostpool</li> <li>emissiontrade</li> </ul> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"model\"][\"emissiontrade module\"] = \"notrade\"\nmodel = MIMOSA(params)\n</code></pre> financialtransfer module <p> </p> <p>Financial transfer module to be used</p> <ul> <li> <p>Type: enum</p> </li> <li> <p>Default: notransfer</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Allowed values:</p> <ul> <li>notransfer</li> <li>globaldamagepool</li> </ul> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"model\"][\"financialtransfer module\"] = \"notransfer\"\nmodel = MIMOSA(params)\n</code></pre> welfare module <p> </p> <p>Welfare and utility module to be used</p> <ul> <li> <p>Type: enum</p> </li> <li> <p>Default: welfare_loss_minimising</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Allowed values:</p> <ul> <li>welfare_loss_minimising</li> <li>cost_minimising</li> <li>inequal_aversion_general</li> </ul> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"model\"][\"welfare module\"] = \"welfare_loss_minimising\"\nmodel = MIMOSA(params)\n</code></pre> objective module <p> </p> <p>Objective module to be used</p> <ul> <li> <p>Type: enum</p> </li> <li> <p>Default: utility</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Allowed values:</p> <ul> <li>utility</li> <li>globalcosts</li> </ul> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"model\"][\"objective module\"] = \"utility\"\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#input_1","title":"input","text":""},{"location":"parameters/#input-variables","title":"input &gt; variables","text":"GDP <p>Data source of GDP</p> <ul> <li> <p>Type: datasource</p> </li> <li> <p>Default: {'variable': 'GDP|PPP', 'unit': 'currency_unit', 'scenario': '{SSP}-Ref-SPA0-V17', 'model': 'IMAGE', 'file': 'inputdata/data/data_IMAGE_SSP.csv'}</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"input\"][\"variables\"][\"GDP\"] = {'variable': 'GDP|PPP', 'unit': 'currency_unit', 'scenario': '{SSP}-Ref-SPA0-V17', 'model': 'IMAGE', 'file': 'inputdata/data/data_IMAGE_SSP.csv'}\nmodel = MIMOSA(params)\n</code></pre> emissions <p> </p> <p>Data source of baseline emissions</p> <ul> <li> <p>Type: datasource</p> </li> <li> <p>Default: {'variable': 'Emissions|CO2', 'unit': 'emissionsrate_unit', 'scenario': '{SSP}-Ref-SPA0-V17', 'model': 'IMAGE', 'file': 'inputdata/data/data_IMAGE_SSP.csv'}</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"input\"][\"variables\"][\"emissions\"] = {'variable': 'Emissions|CO2', 'unit': 'emissionsrate_unit', 'scenario': '{SSP}-Ref-SPA0-V17', 'model': 'IMAGE', 'file': 'inputdata/data/data_IMAGE_SSP.csv'}\nmodel = MIMOSA(params)\n</code></pre> population <p> </p> <p>Data source of population</p> <ul> <li> <p>Type: datasource</p> </li> <li> <p>Default: {'variable': 'Population', 'unit': 'population_unit', 'scenario': '{SSP}-Ref-SPA0-V17', 'model': 'IMAGE', 'file': 'inputdata/data/data_IMAGE_SSP.csv'}</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"input\"][\"variables\"][\"population\"] = {'variable': 'Population', 'unit': 'population_unit', 'scenario': '{SSP}-Ref-SPA0-V17', 'model': 'IMAGE', 'file': 'inputdata/data/data_IMAGE_SSP.csv'}\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#simulation_1","title":"simulation","text":"simulationmode <p>If true, the model is run in simulation mode: then some variables will be imposed exogenously and fixed. If false, <code>constraint_variables</code> and <code>deactivated_constraints</code> are ignored.</p> <ul> <li> <p>Type: bool</p> </li> <li> <p>Default: False</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"simulation\"][\"simulationmode\"] = False\nmodel = MIMOSA(params)\n</code></pre> constraint_variables <p> </p> <p>Dictionary of variable names with associated path to file containing values for that variable</p> <ul> <li> <p>Type: dict</p> </li> <li> <p>Default: None</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"simulation\"][\"constraint_variables\"] = None\nmodel = MIMOSA(params)\n</code></pre> deactivated_constraints <p> </p> <p>List of constraint names to be disabled</p> <ul> <li> <p>Type: list</p> </li> <li> <p>Default: None</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"simulation\"][\"deactivated_constraints\"] = None\nmodel = MIMOSA(params)\n</code></pre> custom_mapping <p> </p> <p>Custom mapping of parameter values or variables</p> <ul> <li> <p>Type: dict</p> </li> <li> <p>Default: None</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"simulation\"][\"custom_mapping\"] = None\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"run/","title":"Running MIMOSA","text":""},{"location":"run/#base-run","title":"Base run","text":"<p>A basic run of MIMOSA requires 4 steps: loading the parameters, building the model instance, solving the model and finally saving the output. With this code, the default parameter values are used (see Parameter reference).</p> <pre><code>from mimosa import MIMOSA, load_params\n\nparams = load_params()  # (1)!\n\nmodel1 = MIMOSA(params) # (2)!\nmodel1.solve() # (3)!\n\nmodel1.save(\"run1\") # (4)!\n</code></pre> <ol> <li>Read the default parameters</li> <li>Build the model using the parameters</li> <li>Once the model is built, send the model to the solver.      Note that if you use the NEOS solver, use the syntax <code>model1.solve(use_neos=True, neos_email=\"your.email@email.com\")</code></li> <li>Export the output to the file output/run1.csv</li> </ol>"},{"location":"run/#reading-the-output","title":"Reading the output","text":"<p>Once the script above has finished running, it has produced two output files in the folder <code>output</code>: <code>run1.csv</code> and <code>run1.csv.params.json</code>. The latter is simply a JSON file with all the input parameter used for this particular run (for reproducibility). The former is a CSV file that contains all the output data. Every variable in MIMOSA is saved in this value in a format similar to IAMC data format:</p> <p> <code>output/run1.csv</code></p> Variable Region Unit 2020 2025 2030 2035 2040 2045 2050 2055 2060 2065 2070 2075 2080 2085 2090 2095 2100 2105 2110 2115 2120 2125 2130 2135 2140 2145 2150 regional_emissions CAN GtCO2/yr 0.511577 0.383683 0.255789 0.155544 0.136527 0.113384 0.0944834 0.0845257 0.077836 0.0694752 0.0588413 0.0469933 0.0359533 0.0269266 0.0199594 0.014565 0.0104499 0.0517489 0.0517486 0.0517485 0.0517484 0.0517483 0.0517482 0.0517481 0.051748 0.0517478 0.0517476 regional_emissions USA GtCO2/yr 5.39382 4.04537 2.69691 1.34846 0.789513 0.649695 0.531854 0.430432 0.341586 0.262853 0.195861 0.142273 0.101621 0.072636 0.0549502 0.0495887 0.0582421 0.534749 0.534749 0.534749 0.534749 0.534749 0.534749 0.534749 0.534749 0.534748 0.534748 regional_emissions MEX GtCO2/yr 0.572878 0.429658 0.286439 0.250682 0.235195 0.210891 0.184067 0.159748 0.137097 0.114491 0.0904155 0.0650686 0.0402638 0.0171455 -0.00403092 -0.0236268 -0.0413935 6.53385e-05 6.49712e-05 6.47857e-05 6.46547e-05 6.45457e-05 6.4444e-05 6.4339e-05 6.42181e-05 6.40555e-05 6.37559e-05 ... ... <p>These output files can be easily imported for plotting software (like using Plotly in Python). An easier way, however, to quickly visualise and compare MIMOSA outputs, is by using the MIMOSA Dashboard. After opening the online Dashboard, simply drag and drop all output files to the drag-and-drop input to visualise one or multiple MIMOSA output files. Also include the parameter files to directly see the difference in input parameters.</p> <p>Open the MIMOSA Dashboard </p>"},{"location":"run/#changing-parameters","title":"Changing parameters","text":"<p>The default parameters from <code>load_params()</code> are given as a nested dictionary. Every item of this dictionary can be changed. Note that only the values can be changed, it is not possible to add or substract parameters to this dictionary (without Extending MIMOSA).</p>"},{"location":"run/#example-1-carbon-budget","title":"Example 1: carbon budget","text":"<pre><code>from mimosa import MIMOSA, load_params\n\nparams = load_params()\n\nparams[\"emissions\"][\"carbonbudget\"] = \"500 GtCO2\" # (1)!\n\nmodel1 = MIMOSA(params)\nmodel1.solve()\n\nmodel1.save(\"run_example1\")\n</code></pre> <ol> <li>Change the parameter of emissions &gt; carbonbudget to the string \"500 GtCO2\"</li> </ol>"},{"location":"run/#example-2-high-damages-high-tcre-low-discounting","title":"Example 2: high damages, high TCRE, low discounting","text":"<p>Multiple parameters can also be changed at the same time. In this example, the high end of the damages and of the climate sensitivity (TCRE) are used, combined with the low end of the discount rate (PRTP).</p> <pre><code>from mimosa import MIMOSA, load_params\n\nparams = load_params()\n\nparams[\"economics\"][\"damages\"][\"quantile\"] = 0.95\nparams[\"temperature\"][\"TCRE\"] = \"0.82 delta_degC/(TtCO2)\"\nparams[\"economics\"][\"PRTP\"] = 0.001\n\nmodel2 = MIMOSA(params)\nmodel2.solve()\n\nmodel2.save(\"run_example2\")\n</code></pre>"},{"location":"run/#doing-multiple-runs","title":"Doing multiple runs","text":"<p>Often, MIMOSA needs to be run with multiple values of the same parameter (multiple carbon budgets, multiple discount rates, etc.). While it is possible to simply run the file multiple times, it is much easier to run MIMOSA multiple times directly in the Python script through regular Python loops:</p> <pre><code>from mimosa import MIMOSA, load_params\n\nfor budget in [\"500 GtCO2\", \"700 GtCO2\", \"1000 GtCO2\"]:\n\n     params = load_params()\n\n     params[\"emissions\"][\"carbonbudget\"] = budget\n\n     model3 = MIMOSA(params)\n     model3.solve()\n\n     model3.save(f\"run_example3_{budget}\") # (1)!\n</code></pre> <ol> <li>Don't forget to save each file to a different name, otherwise they will be overwritten at each iteration of the loop.</li> </ol>"},{"location":"run/#doing-a-baseline-run","title":"Doing a baseline run","text":"<p>It can be useful to do a MIMOSA run with zero mitigation: a baseline run. We distinguish two types of baseline runs: either ignoring damages (the true baseline run, in absence of climate policy and climate impacts), or with damages (a no-policy scenario, mainly to investigate the damages if no climate policy were implemented).</p> Baseline ignoring damagesNo policy scenario with damages <pre><code>from mimosa import MIMOSA, load_params\n\nparams = load_params()\n\nparams[\"emissions\"][\"carbonbudget\"] = False\nparams[\"economics\"][\"damages\"][\"ignore damages\"] = True\n\nparams[\"model\"][\"welfare module\"] = \"cost_minimising\"\n\n# Disable some emission reduction constraints\nparams[\"emissions\"][\"non increasing emissions after 2100\"] = False\nparams[\"emissions\"][\"not positive after budget year\"] = False\nparams[\"emissions\"][\"inertia\"][\"regional\"] = False\nparams[\"emissions\"][\"inertia\"][\"global\"] = False\n\nparams[\"time\"][\"end\"] = 2150\n\nmodel = MIMOSA(params)\nmodel.solve()\nmodel.save(\"baseline_ignore_damages\")\n</code></pre> <pre><code>from mimosa import MIMOSA, load_params\n\nparams = load_params()\n\nparams[\"emissions\"][\"carbonbudget\"] = False\nparams[\"economics\"][\"damages\"][\"ignore damages\"] = False # (1)!\nparams[\"model\"][\"welfare module\"] = \"cost_minimising\"\n\n# Force the mitigation effort to be zero\nparams[\"simulation\"][\"simulationmode\"] = True\nparams[\"simulation\"][\"constraint_variables\"] = {\n     \"relative_abatement\": {\n          year: {region: 0.0 for region in params[\"regions\"]}\n          for year in range(2025, 2151, 5)\n     },\n}\nparams[\"economics\"][\"MAC\"][\"gamma\"] = \"0.00001 USD2005/tCO2\" # (2)!\n\n# Disable some emission reduction constraints\nparams[\"emissions\"][\"non increasing emissions after 2100\"] = False\nparams[\"emissions\"][\"not positive after budget year\"] = False\nparams[\"emissions\"][\"inertia\"][\"regional\"] = False\nparams[\"emissions\"][\"inertia\"][\"global\"] = False\n\nparams[\"time\"][\"end\"] = 2150\n\nmodel = MIMOSA(params)\nmodel.solve()\nmodel.save(\"baseline_no_policy\")\n</code></pre> <ol> <li>This is default, so this line could be removed</li> <li>Needed for numerical stability</li> </ol>"},{"location":"run/#doing-an-effort-sharing-run","title":"Doing an effort-sharing run","text":"<p>MIMOSA has some built-in effort sharing regimes. In this example, they are used in combination with a carbon budget (but it could be used in CBA mode). The welfare module is set to cost minimising, as this is typically used with effort sharing regimes. Effort sharing would be impossible without emission trading. Finally, this would often be infeasible for some regions, if we didn't allow for some extra financial transfers beyond just emission trading, which is why we set the relative mitigation cost minimum level to a small negative number.</p> <pre><code>from mimosa import MIMOSA, load_params\n\n\n# Loop over the three available effort sharing regimes\nfor regime in [\n     \"equal_mitigation_costs\",\n     \"equal_total_costs\",\n     \"per_cap_convergence\",\n]:\n     params = load_params()\n     params[\"model\"][\"emissiontrade module\"] = \"emissiontrade\"\n     params[\"model\"][\"welfare module\"] = \"cost_minimising\"\n     params[\"emissions\"][\"carbonbudget\"] = \"700 GtCO2\"\n     params[\"effort sharing\"][\"regime\"] = regime\n     params[\"economics\"][\"MAC\"][\"rel_mitigation_costs_min_level\"] = -0.3\n     params[\"time\"][\"end\"] = 2100\n\n     model1 = MIMOSA(params)\n     model1.solve()\n     model1.save(f\"run_{regime}\")\n</code></pre>"},{"location":"run/#advanced-logging","title":"Advanced: logging","text":"<p>The solve status (optimal, impossible, etc), model solve time and the final maximised value can be logged to an external log file (along with the warnings or errors from the code). This can be very useful when doing many runs overnight. In this code example, the log is written to the file <code>mainlog.log</code>:</p> <pre><code>import logging\nimport logging.handlers\n\nfrom mimosa import MIMOSA, load_params\n\nhandler = logging.handlers.WatchedFileHandler(\"mainlog.log\")\nhandler.setFormatter(\n    logging.Formatter(\"[%(levelname)s, %(asctime)s] %(name)s - %(message)s\")\n)\nroot = logging.getLogger()\nroot.setLevel(\"INFO\")\nroot.addHandler(handler)\n\nparams = load_params()\n\n# Make changes to the params if needed\nparams[\"emissions\"][\"carbonbudget\"] = False\n\nmodel1 = MIMOSA(params)\nmodel1.solve(verbose=False) # (1)!\nmodel1.save(\"run1\")\n</code></pre> <ol> <li>By setting <code>verbose=False</code>, the IPOPT output is not printed.      If you're doing many runs, this is probably useful. The termination status of IPOPT is      logged to the log file anyway.</li> </ol>"},{"location":"components/","title":"Documentation of model components","text":"<p>The MIMOSA model consists of several sub-modules, called model components. Each component is made up of multiple variables (global or regional), parameters and equations (called constraints).</p>"},{"location":"components/#economics","title":"Economics","text":"<p>Cobb-Douglas production function, investments, consumption and capital stock</p> <p> Read more</p>"},{"location":"components/#welfare","title":"Welfare","text":"<p>Welfare and the utility function</p> <p> Read more</p>"},{"location":"components/#emissions-and-temperature","title":"Emissions and temperature","text":"<ul> <li>Baseline emissions, regional mitigated emissions and cumulative emissions</li> <li>Temperature module</li> <li>Constraints on emissions like inertia</li> </ul> <p> Read more</p>"},{"location":"components/#mitigation","title":"Mitigation","text":"<p>Mitigation costs, Marginal Abatement Cost curve and technological learning</p> <p> Read more</p>"},{"location":"components/#sea-level-rise","title":"Sea-level rise","text":"<p>Determines the level of global sea-level rise</p> <p> Read more</p>"},{"location":"components/#damages","title":"Damages","text":"<p>Temperature related damages and sea-level rise related damages</p> <p> Read more</p>"},{"location":"components/#effort-sharing","title":"Effort-sharing","text":"<p><code>Optional</code> Various effort-sharing regimes to distribute the mitigation (and sometimes damage) costs</p> <p> Read more</p>"},{"location":"components/#emission-trading","title":"Emission trading","text":"<p><code>Optional</code> Allows for global trade of emission reductions</p> <p> Read more</p>"},{"location":"components/#financial-transfers","title":"Financial transfers","text":"<p><code>Optional</code> Financial transfer schemes like a global damage cost pool</p> <p> Read more</p>"},{"location":"components/#mimosa.abstract_model.create_abstract_model--building-the-abstract-model","title":"Building the abstract model","text":"<p>Builds the abstract model for MIMOSA by combining all components. Some components are optional. In the parameters, different variants of some components can be chosen. The components are:</p> <ul> <li><code>damage_module</code>: The damage module to use</li> <li><code>emissiontrade_module</code>: The emission trading module to use</li> <li><code>financialtransfer_module</code>: The financial transfer module to use</li> <li><code>welfare_module</code>: The welfare module to use</li> <li><code>objective_module</code>: The objective module to use</li> </ul> Source code in <code>mimosa/abstract_model.py</code> <pre><code>def create_abstract_model(\n    damage_module: str,\n    emissiontrade_module: str,\n    financialtransfer_module: str,\n    welfare_module: str,\n    objective_module: str,\n) -&gt; AbstractModel:\n    \"\"\"\n    ## Building the abstract model\n\n    Builds the abstract model for MIMOSA by combining all components. Some components are optional. In the\n    parameters, different variants of some components can be chosen. The components are:\n\n    - [`damage_module`](../parameters.md#model.damage%20module): The damage module to use\n    - [`emissiontrade_module`](../parameters.md#model.emissiontrade%20module): The emission trading module to use\n    - [`financialtransfer_module`](../parameters.md#model.financialtransfer%20module): The financial transfer module to use\n    - [`welfare_module`](../parameters.md#model.welfare%20module): The welfare module to use\n    - [`objective_module`](../parameters.md#model.objective%20module): The objective module to use\n\n    \"\"\"\n    m = AbstractModel()\n\n    ## Constraints\n    # Each constraint will be put in this list,\n    # then added to the model at the end of this file.\n    constraints = []\n\n    ## Time and region\n    m.beginyear = Param()\n    m.dt = Param()\n    m.tf = Param()\n    m.t = Set()\n    m.year = None  # Initialised with concrete instance\n    m.year2100 = Param()\n\n    m.regions = Set(ordered=True)\n\n    ######################\n    # Create data params for baseline values\n    ######################\n\n    m.population = Param(\n        m.t,\n        m.regions,\n        doc=\"timeandregional::population\",\n        units=quant.unit(\"billion people\"),\n    )\n    m.baseline_GDP = Param(\n        m.t,\n        m.regions,\n        doc=\"timeandregional::GDP\",\n        units=quant.unit(\"currency_unit\"),\n    )\n    m.baseline_emissions = Param(\n        m.t,\n        m.regions,\n        doc=\"timeandregional::emissions\",\n        units=quant.unit(\"emissionsrate_unit\"),\n    )\n\n    ######################\n    # Components\n    ######################\n\n    # Emissions and temperature equations\n    constraints.extend(emissions.get_constraints(m))\n\n    # Sea level rise\n    constraints.extend(sealevelrise.get_constraints(m))\n\n    # Damage costs\n    if damage_module == \"COACCH\":\n        constraints.extend(damages.coacch.get_constraints(m))\n    elif damage_module == \"nodamage\":\n        constraints.extend(damages.nodamage.get_constraints(m))\n    else:\n        raise NotImplementedError\n\n    # Abatement costs\n    constraints.extend(mitigation.get_constraints(m))\n\n    # Emission trading\n    if emissiontrade_module == \"notrade\":\n        constraints.extend(emissiontrade.notrade.get_constraints(m))\n    elif emissiontrade_module == \"globalcostpool\":\n        constraints.extend(emissiontrade.globalcostpool.get_constraints(m))\n    elif emissiontrade_module == \"emissiontrade\":\n        constraints.extend(emissiontrade.emissiontrade.get_constraints(m))\n    else:\n        raise NotImplementedError(\n            f\"Emission trading module `{emissiontrade_module}` not implemented\"\n        )\n\n    # Financial transfer\n    if financialtransfer_module == \"notransfer\":\n        constraints.extend(financialtransfer.notransfer.get_constraints(m))\n    elif financialtransfer_module == \"globaldamagepool\":\n        constraints.extend(financialtransfer.globaldamagepool.get_constraints(m))\n    else:\n        raise NotImplementedError(\n            f\"Financial transfer module `{financialtransfer_module}` not implemented\"\n        )\n\n    # Effort sharing regime\n    constraints.extend(effortsharing.get_constraints(m))\n\n    # Cobb-Douglas and economics\n    constraints.extend(cobbdouglas.get_constraints(m))\n\n    # Utility and welfare\n    if welfare_module == \"welfare_loss_minimising\":\n        constraints.extend(welfare.welfare_loss_minimising.get_constraints(m))\n    elif welfare_module == \"cost_minimising\":\n        constraints.extend(welfare.cost_minimising.get_constraints(m))\n    elif welfare_module == \"inequal_aversion_general\":\n        constraints.extend(welfare.inequal_aversion_general.get_constraints(m))\n    else:\n        raise NotImplementedError(f\"Welfare module `{welfare_module}` not implemented\")\n\n    # Objective of optimisation\n    if objective_module == \"utility\":\n        objective_rule, objective_constraints = objective.utility.get_constraints(m)\n    elif objective_module == \"globalcosts\":\n        objective_rule, objective_constraints = objective.globalcosts.get_constraints(m)\n    else:\n        raise NotImplementedError\n\n    constraints.extend(objective_constraints)\n\n    ######################\n    # Add constraints to abstract model\n    ######################\n\n    for constraint in constraints:\n        add_constraint(m, constraint.to_pyomo_constraint(m), constraint.name)\n\n    m.obj = objective_rule\n\n    return m\n</code></pre>"},{"location":"components/damages/","title":"Damages","text":"<p> Back to general structure</p> <p>Climate impacts in MIMOSA are calculated using the COACCH damage functions, developed in 2023 (see van der Wijst et al., 2023).</p> <p>The COACCH damage functions are split in two parts: temperature-dependent damages (non-SLR, as a function of global mean temperature above pre-industrial), and sea-level rise damages (SLR, as function of global mean sea-level rise in meters).</p>"},{"location":"components/damages/#mimosa.components.damages.coacch.get_constraints--temperature-dependent-damages","title":"Temperature-dependent damages","text":"<p>The temperature-dependent damages are modeled as a quadratic damage function \\(D(\\cdot)\\) of global mean temperature:</p> \\[ D(x; b_1, b_2) = b_1 \\cdot x + b_2 \\cdot x^2. \\] <p>To calculate the damages, three transformations have to be taken from the above quadratic equation:</p> <ul> <li>The COACCH damage functions were created as function of temperature relative to 1986-2005, which is 0.6\u00b0C above pre-industrial.     For this reason, the temperature is shifted by 0.6\u00b0C.</li> <li>The damages are scaled by a factor \\(a_{q,r}\\), which depends on the quantile \\(q\\) of the damage function. This represents the uncertainty     in the damage function. For median damages, this factor is \\(a_{0.5,r} = 1\\). The quantile can be set using the damage quantile parameter.</li> <li>Since we assume that until 2020 the climate damages are already incorporated in the baseline GDP,     we subtract the damages of the initial time period \\(t=0\\).</li> </ul> <p>Combining these three transformations, the damages are calculated as:</p> \\[ \\text{damages}_{\\text{non-SLR},t,r} = a_{q,r} \\cdot \\big( D(\\text{temperature}_t - 0.6; b_{1,r}, b_{2,r}) -  D(T_0 - 0.6; b_{1,r}, b_{2,r}) \\big). \\] <p>All the damage coefficients are region-dependent (see Damage functions and coefficients).</p>"},{"location":"components/damages/#mimosa.components.damages.coacch.get_constraints--temperature-dependent-damages-aggregated-to-the-world-and-comparison-with-the-literature","title":"Temperature-dependent damages aggregated to the world, and comparison with the literature:","text":""},{"location":"components/damages/#mimosa.components.damages.coacch.get_constraints--sea-level-rise-damages","title":"Sea-level rise damages","text":"<p>...</p> Source code in <code>mimosa/components/damages/coacch.py</code> <pre><code>def get_constraints(m: AbstractModel) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n    The COACCH damage functions are split in two parts: temperature-dependent damages (non-SLR, as a function\n    of global mean temperature above pre-industrial), and sea-level rise damages (SLR, as function of global mean\n    sea-level rise in meters).\n\n    ## Temperature-dependent damages\n\n    The temperature-dependent damages are modeled as a quadratic damage function $D(\\\\cdot)$ of global mean temperature:\n\n    $$\n    D(x; b_1, b_2) = b_1 \\\\cdot x + b_2 \\\\cdot x^2.\n    $$\n\n    To calculate the damages, three transformations have to be taken from the above quadratic equation:\n\n    * The COACCH damage functions were created as function of temperature relative to 1986-2005, which is 0.6\u00b0C above pre-industrial.\n        For this reason, the temperature is shifted by 0.6\u00b0C.\n    * The damages are scaled by a factor $a_{q,r}$, which depends on the quantile $q$ of the damage function. This represents the uncertainty\n        in the damage function. For median damages, this factor is $a_{0.5,r} = 1$. The quantile can be set using the [damage quantile parameter](../parameters.md#economics.damages.quantile).\n    * Since we assume that until 2020 the climate damages are already incorporated in the baseline GDP,\n        we subtract the damages of the initial time period $t=0$.\n\n    Combining these three transformations, the damages are calculated as:\n\n    $$\n    \\\\text{damages}_{\\\\text{non-SLR},t,r} = a_{q,r} \\\\cdot \\\\big( D(\\\\text{temperature}_t - 0.6; b_{1,r}, b_{2,r}) -  D(T_0 - 0.6; b_{1,r}, b_{2,r}) \\\\big).\n    $$\n\n    All the damage coefficients are region-dependent (see [Damage functions and coefficients](./#damage-functions-and-coefficients)).\n\n    ### Temperature-dependent damages aggregated to the world, and comparison with the literature:\n\n    ``` plotly\n    {\"file_path\": \"./assets/plots/coacch_literature_comparison.json\"}\n    ```\n\n    ## Sea-level rise damages\n\n    ...\n\n    \"\"\"\n    constraints = []\n\n    m.damage_costs = Var(m.t, m.regions, units=quant.unit(\"fraction_of_GDP\"))\n    m.damage_scale_factor = Param(doc=\"::economics.damages.scale factor\")\n\n    # Damages not related to SLR (dependent on temperature)\n    m.damage_costs_non_slr = Var(m.t, m.regions, units=quant.unit(\"fraction_of_GDP\"))\n\n    m.damage_noslr_form = Param(\n        m.regions, within=Any, doc=\"regional::COACCH.NoSLR_form\"\n    )  # String for functional form\n    m.damage_noslr_b1 = Param(m.regions, doc=\"regional::COACCH.NoSLR_b1\")\n    m.damage_noslr_b2 = Param(m.regions, doc=\"regional::COACCH.NoSLR_b2\")\n    m.damage_noslr_b3 = Param(\n        m.regions, within=Any, doc=\"regional::COACCH.NoSLR_b3\"\n    )  # Can be empty\n    # (b2 and b3 are only used for some functional forms)\n\n    m.damage_noslr_a = Param(\n        m.regions,\n        doc=lambda params: f'regional::COACCH.NoSLR_a (q={params[\"economics\"][\"damages\"][\"quantile\"]})',\n    )\n\n    # Quadratic damage function for non-SLR damages. Factor `a` represents\n    # the damage quantile\n    constraints.append(\n        RegionalConstraint(\n            lambda m, t, r: m.damage_costs_non_slr[t, r]\n            == m.damage_scale_factor\n            * damage_fct(m.temperature[t] - 0.6, m.T0 - 0.6, m, r, is_slr=False),\n            \"damage_costs_non_slr\",\n        )\n    )\n\n    # SLR damages\n    m.damage_costs_slr = Var(\n        m.t, m.regions, bounds=(-0.5, 0.7), units=quant.unit(\"fraction_of_GDP\")\n    )\n\n    def slr_param_name(params, name):\n        \"\"\"Returns the parameter name regional::COACCH.SLR... depending on if adaptation is included or not.\"\"\"\n        slr_with_adapt = params[\"economics\"][\"damages\"][\"coacch_slr_withadapt\"]\n        return f'regional::COACCH.SLR-{\"Ad\" if slr_with_adapt else \"NoAd\"}_{name}'\n\n    m.damage_slr_form = Param(\n        m.regions,\n        within=Any,\n        doc=lambda params: slr_param_name(params, \"form\"),\n    )  # String for functional form\n    m.damage_slr_b1 = Param(\n        m.regions,\n        doc=lambda params: slr_param_name(params, \"b1\"),\n    )\n    m.damage_slr_b2 = Param(\n        m.regions,\n        within=Any,\n        doc=lambda params: slr_param_name(params, \"b2\"),\n    )  # within=Any since it can be empty for some functional forms\n    m.damage_slr_b3 = Param(\n        m.regions,\n        within=Any,\n        doc=lambda params: slr_param_name(params, \"b3\"),\n    )  # within=Any since it can be empty for some functional forms\n    # (b2 and b3 are only used for some functional forms)\n\n    m.damage_slr_a = Param(\n        m.regions,\n        doc=lambda params: slr_param_name(\n            params, f'a (q={params[\"economics\"][\"damages\"][\"quantile\"]})'\n        ),\n    )\n\n    # Linear damage function for SLR damages, including adaptation costs\n    constraints.append(\n        RegionalConstraint(\n            lambda m, t, r: m.damage_costs_slr[t, r]\n            == m.damage_scale_factor\n            * damage_fct(m.total_SLR[t], m.total_SLR[0], m, r, is_slr=True),\n            \"damage_costs_slr\",\n        )\n    )\n\n    # Total damages are sum of non-SLR and SLR damages\n    constraints.append(\n        RegionalConstraint(\n            lambda m, t, r: m.damage_costs[t, r]\n            == m.damage_costs_non_slr[t, r] + m.damage_costs_slr[t, r],\n            \"damage_costs\",\n        ),\n    )\n\n    return constraints\n</code></pre>"},{"location":"components/damages/#damage-functions-and-coefficients","title":"Damage functions and coefficients","text":"Visualisation of damage functions and damage coefficients <p> Download COACCH damage function coefficients</p> Non-SLR damagesSLR damages (optimal adaptation)SLR damages (no adaptation)Combined SLR and non-SLR damages <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"components/damages/#impact-sectors-used-in-the-damage-functions","title":"Impact sectors used in the damage functions","text":"Climate change impact area Model source Variable used in CGE  Agriculture EPIC biophysical model  and GLOBIOM model (Change in) Crop yield  Forestry G4M model (Change in) Net physical wood production per hectare  Fishery DBEM envelope model  and DSFM food web model (Change in) Fish catches  Sea-level rise DIVA model - Annual land loss due to submergence- Expected annual damages to assets- Expected annual number of people flooded- Annual protection costs  Riverine floods GLOFRIS model - Expected annual damages for the industrial, commercial, and residential sectors- Expected annual number of people flooded  Road transportation OSDaMage model Expected annual damages for the road infrastructure  Energy supply Schleypen et al. (2019) Changes in wind and hydropower production  Energy demand Schleypen et al. (2019) Changes in energy demand by households and by the industrial, agricultural and service sectors for coal, oil, gas, and electricity  Labour productivity Dasgupta et al. (2022) Changes in per capita production of value added"},{"location":"components/economics/","title":"Economics","text":"<p> Back to general structure</p>"},{"location":"components/economics/#mimosa.components.cobbdouglas.get_constraints--economic-module-and-production-function","title":"Economic module and production function","text":""},{"location":"components/economics/#mimosa.components.cobbdouglas.get_constraints--gross-and-net-gdp","title":"Gross and net GDP","text":"<p>The core of the model is the economic module, detailing how GDP, investments and consumptions vary over time. We use a traditional Cobb-Douglas production function. This means that the gross GDP is calculated by:</p> <p>$$ \\text{GDP}_{\\text{gross},t,r} = \\text{TFP}_{t,r} \\cdot L^{1-\\alpha}_{t,r} \\cdot K^{\\alpha}_{t,r}, $$ with \\(\\text{TFP}\\) the total factor productivity (exogenously calibrated from the baseline SSP scenarios) \\(L\\) the labor (represented by the total population), \\(K\\) the capital stock and \\(\\alpha\\) the share of capital in the production function.</p> Source code in <code>mimosa/common/economics.py</code> <pre><code>def calc_GDP(TFP, L, K, alpha):\n    \"\"\"\n    $$ \\\\text{GDP}_{\\\\text{gross},t,r} = \\\\text{TFP}\\\\_{t,r} \\\\cdot L^{1-\\\\alpha}\\\\_{t,r} \\\\cdot K^{\\\\alpha}\\\\_{t,r}, $$\n    with $\\\\text{TFP}$ the total factor productivity (exogenously calibrated from the baseline SSP scenarios)\n    $L$ the labor (represented by the total population), $K$ the capital stock and $\\\\alpha$ the share of capital in the production function.\n\n    \"\"\"\n    return TFP * L ** (1 - alpha) * K**alpha\n</code></pre> <p>The net GDP is then calculated by subtracting the damages and mitigation costs from the gross GDP. (Note that in MIMOSA, the damages are expressed as a fraction of the gross GDP, whereas the mitigation costs are expressed in absolute terms.)</p> \\[ \\text{GDP}_{\\text{net},t,r} = \\text{GDP}_{\\text{gross},t,r} \\cdot (1 - \\text{damage costs}_{t,r}) - \\text{mitigation costs}_{t,r}\\]"},{"location":"components/economics/#mimosa.components.cobbdouglas.get_constraints--investments-and-consumption","title":"Investments and consumption","text":"<p>This net GDP is then split in a part of investments (\\(I_t\\)) and a part of consumption (\\(C_t\\)), according to a fixed savings rate (\\(\\text{sr}\\)):</p> \\[ I_{t,r} = \\text{sr} \\cdot \\text{GDP}_{\\text{net},t,r}, \\] \\[ C_{t,r} = (1 - \\text{sr}) \\cdot \\text{GDP}_{\\text{net},t,r}. \\]"},{"location":"components/economics/#mimosa.components.cobbdouglas.get_constraints--capital-stock","title":"Capital stock","text":"<p>The capital stock \\(K_t\\) grows over time according to the investments and the depreciation of the capital stock:</p> \\[ K_{t,r} = K_{t-1,r} + \\Delta t \\cdot \\frac{\\partial K_{t,r}}{\\partial t}, \\] <p>with the change in capital stock calculated by:</p> \\[ \\frac{\\partial K_{t,r}}{\\partial t} = \\frac{1}{\\Delta t} \\cdot ((1 - dk)^{\\Delta t}  - 1) \\cdot K_{t,r} + I_{t,r}.\\] Source code in <code>mimosa/common/economics.py</code> <pre><code>def calc_dKdt(K, dk, I, dt):\n    \"\"\"\n    $$ \\\\frac{\\\\partial K_{t,r}}{\\\\partial t} = \\\\frac{1}{\\\\Delta t} \\\\cdot ((1 - dk)^{\\\\Delta t}  - 1) \\\\cdot K_{t,r} + I_{t,r}.$$\n    \"\"\"\n    return ((1 - dk) ** dt - 1) / dt * K + I\n</code></pre> <p>Since this only gives the change in capital stock, we need to add the initial capital stock to get the actual capital stock. This is calculated as a region-dependent multiple of the initial GDP:</p> \\[ K_{t=0,r} = \\text{init_capitalstock_factor}_r \\cdot \\text{GDP}_{t=0,r}. \\] <p>The initial capital stock factor is a calibration factor to obtain the initial capital stock. TODO: Source (IMF) </p>"},{"location":"components/economics/#mimosa.components.cobbdouglas.get_constraints--parameters-defined-in-this-module","title":"Parameters defined in this module","text":"<ul> <li><code>init_capitalstock_factor</code></li> <li><code>alpha</code>: Output elasticity of capital. Type: float. Default: 0.3. Min: 0. Max: 1.</li> <li><code>dk</code>: Yearly depreciation rate of capital stock. Type: float. Default: 0.05. Min: 0. Max: inf.</li> <li><code>sr</code>: Fraction of GDP used for investments. Type: float. Default: 0.21. Min: 0. Max: 1.</li> <li><code>ignore_damages</code>: Flag to not take into account the damages in the GDP (but damages are calculated). Type: bool. Default: False.</li> </ul> Source code in <code>mimosa/components/cobbdouglas.py</code> <pre><code>def get_constraints(m: AbstractModel) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n    # Economic module and production function\n\n    ## Gross and net GDP\n\n    The core of the model is the economic module, detailing how GDP, investments and\n    consumptions vary over time. We use a traditional Cobb-Douglas production function. This means\n    that the gross GDP is calculated by:\n\n    :::mimosa.common.economics.calc_GDP\n\n    The net GDP is then calculated by subtracting the damages and\n    mitigation costs from the gross GDP. *(Note that in MIMOSA, the damages are expressed as a fraction of the gross GDP,\n    whereas the mitigation costs are expressed in absolute terms.)*\n\n    $$ \\\\text{GDP}_{\\\\text{net},t,r} = \\\\text{GDP}_{\\\\text{gross},t,r} \\\\cdot (1 - \\\\text{damage costs}_{t,r}) - \\\\text{mitigation costs}_{t,r}$$\n\n    ## Investments and consumption\n\n    This net GDP is then split in a part of investments ($I_t$) and a part of consumption ($C_t$), according to a fixed savings rate ($\\\\text{sr}$):\n\n    $$ I_{t,r} = \\\\text{sr} \\\\cdot \\\\text{GDP}_{\\\\text{net},t,r}, $$\n\n    $$ C_{t,r} = (1 - \\\\text{sr}) \\\\cdot \\\\text{GDP}_{\\\\text{net},t,r}. $$\n\n    ## Capital stock\n\n    The capital stock $K_t$ grows over time according to the investments and the depreciation of the capital stock:\n\n    $$ K_{t,r} = K_{t-1,r} + \\\\Delta t \\\\cdot \\\\frac{\\\\partial K_{t,r}}{\\\\partial t}, $$\n\n    with the change in capital stock calculated by:\n\n    :::mimosa.common.economics.calc_dKdt\n\n    Since this only gives the change in capital stock, we need to add the initial capital stock to get the actual capital stock.\n    This is calculated as a region-dependent multiple of the initial GDP:\n\n    $$ K_{t=0,r} = \\\\text{init_capitalstock_factor}_r \\\\cdot \\\\text{GDP}_{t=0,r}. $$\n\n    The initial capital stock factor is a calibration factor to obtain the initial capital stock. TODO: Source (IMF)\n    ``` plotly\n    {\"file_path\": \"./assets/plots/economics_init_capital_factor.json\"}\n    ```\n\n    ## Parameters defined in this module\n    - <code>init_capitalstock_factor</code>\n    - <code>alpha</code>: Output elasticity of capital. Type: float. Default: 0.3. Min: 0. Max: 1.\n    - <code>dk</code>: Yearly depreciation rate of capital stock. Type: float. Default: 0.05. Min: 0. Max: inf.\n    - <code>sr</code>: Fraction of GDP used for investments. Type: float. Default: 0.21. Min: 0. Max: 1.\n    - <code>ignore_damages</code>: Flag to not take into account the damages in the GDP (but damages are calculated). Type: bool. Default: False.\n\n\n\n    \"\"\"\n    constraints = []\n\n    m.init_capitalstock_factor = Param(\n        m.regions,\n        units=quant.unit(\"dimensionless\"),\n        doc=\"regional::economics.init_capital_factor\",\n    )\n    m.capital_stock = Var(\n        m.t,\n        m.regions,\n        initialize=lambda m, t, r: m.init_capitalstock_factor[r] * m.baseline_GDP[t, r],\n        units=quant.unit(\"currency_unit\"),\n    )\n\n    # Parameters\n    m.alpha = Param(doc=\"::economics.GDP.alpha\")\n    m.dk = Param(doc=\"::economics.GDP.depreciation of capital\")\n    m.sr = Param(doc=\"::economics.GDP.savings rate\")\n\n    m.GDP_gross = Var(\n        m.t,\n        m.regions,\n        initialize=lambda m, t, r: m.baseline_GDP[0, r],\n        units=quant.unit(\"currency_unit\"),\n    )\n    m.GDP_net = Var(\n        m.t,\n        m.regions,\n        units=quant.unit(\"currency_unit\"),\n        initialize=lambda m, t, r: m.baseline_GDP[0, r],\n    )\n    m.investments = Var(m.t, m.regions, units=quant.unit(\"currency_unit\"))\n    m.consumption = Var(m.t, m.regions, units=quant.unit(\"currency_unit\"))\n\n    m.ignore_damages = Param(doc=\"::economics.damages.ignore damages\")\n\n    m.TFP = Param(m.t, m.regions, initialize=economics.get_TFP_value)\n\n    # Cobb-Douglas, GDP, investments, capital and consumption\n    constraints.extend(\n        [\n            RegionalConstraint(\n                lambda m, t, r: (\n                    m.GDP_gross[t, r]\n                    == economics.calc_GDP(\n                        m.TFP[t, r],\n                        m.population[t, r],\n                        soft_min(m.capital_stock[t, r], scale=10),\n                        m.alpha,\n                    )\n                    if t &gt; 0\n                    else Constraint.Skip\n                ),\n                \"GDP_gross\",\n            ),\n            RegionalInitConstraint(\n                lambda m, r: m.GDP_gross[0, r] == m.baseline_GDP[0, r], \"GDP_gross_init\"\n            ),\n            RegionalConstraint(\n                lambda m, t, r: m.GDP_net[t, r]\n                == m.GDP_gross[t, r]\n                * (1 - (m.damage_costs[t, r] if not value(m.ignore_damages) else 0))\n                - m.mitigation_costs[t, r]\n                - m.financial_transfer[t, r],\n                \"GDP_net\",\n            ),\n            RegionalConstraint(\n                lambda m, t, r: m.investments[t, r] == m.sr * m.GDP_net[t, r],\n                \"investments\",\n            ),\n            RegionalConstraint(\n                lambda m, t, r: m.consumption[t, r] == (1 - m.sr) * m.GDP_net[t, r],\n                \"consumption\",\n            ),\n            RegionalConstraint(\n                lambda m, t, r: (\n                    (\n                        m.capital_stock[t, r]\n                        == m.capital_stock[t - 1, r]\n                        + m.dt\n                        * economics.calc_dKdt(\n                            m.capital_stock[t, r], m.dk, m.investments[t, r], m.dt\n                        )\n                    )\n                    if t &gt; 0\n                    else Constraint.Skip\n                ),\n                \"capital_stock\",\n            ),\n            RegionalInitConstraint(\n                lambda m, r: m.capital_stock[0, r]\n                == m.init_capitalstock_factor[r] * m.baseline_GDP[0, r]\n            ),\n        ]\n    )\n\n    return constraints\n</code></pre>"},{"location":"components/effortsharing/","title":"Effort-sharing","text":"<p> Back to general structure</p> <p>Effort-sharing regimes can be used to enforce the redistribution of mitigation effort and damage costs among regions following pre-defined equity principles. By default, in MIMOSA, no effort-sharing regime is imposed.</p> <p>Besides no regime at all, there are three types of effort-sharing regimes implemented in MIMOSA. This can be set using the <code>effort_sharing_regime</code> parameter:</p> <ul> <li><code>noregime</code> (default): No effort-sharing regime is imposed.</li> <li><code>equal_mitigation_costs</code>: Mitigation costs equal among regions as a percentage of GDP.</li> <li><code>equal_total_costs</code>: Total costs (mitigation costs + damage costs) equal among regions as a percentage of GDP.</li> <li><code>per_cap_convergence</code>: Per capita emissions converge to a common level.</li> </ul> Equal mitigation costsEqual total costsPer capita convergence <p>In this regime, the mitigation costs should be equal among regions as a percentage of GDP.</p> <p>In this regime, the total costs (mitigation costs + damage costs + financial transfers) should be equal among regions as a percentage of GDP.</p> <p>In this regime, the per capita emissions should converge to a common level. The common level is calculated as the weighted average of the per capita emissions of all regions. The weights are the population shares of the regions.</p> Source code in <code>mimosa/components/effortsharing.py</code> <pre><code>def get_constraints(m: AbstractModel) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n    Effort-sharing regimes can be used to enforce the redistribution of mitigation effort and damage costs among\n    regions following pre-defined equity principles. By default, in MIMOSA, no effort-sharing regime is imposed.\n\n    Besides no regime at all, there are three types of effort-sharing regimes implemented in MIMOSA. This can be\n    set using the [`effort_sharing_regime`](../parameters.md#effort sharing.regime) parameter:\n\n    - `noregime` (default): No effort-sharing regime is imposed.\n    - [`equal_mitigation_costs`](#equal-mitigation-costs): Mitigation costs equal among regions as a percentage of GDP.\n    - [`equal_total_costs`](#equal-total-costs): Total costs (mitigation costs + damage costs) equal among regions as a percentage of GDP.\n    - [`per_cap_convergence`](#per-capita-convergence): Per capita emissions converge to a common level.\n\n\n    === \"Equal mitigation costs\"\n        In this regime, the mitigation costs should be equal among regions as a percentage of GDP.\n\n    === \"Equal total costs\"\n        In this regime, the total costs (mitigation costs + damage costs + financial transfers) should be equal among regions as a percentage of GDP.\n\n    === \"Per capita convergence\"\n        In this regime, the per capita emissions should converge to a common level. The common level is calculated as the weighted average of the per capita emissions of all regions. The weights are the population shares of the regions.\n    \"\"\"\n    constraints = []\n\n    m.effort_sharing_regime = Param(within=Any, doc=\"::effort sharing.regime\")\n\n    ## effort sharing scheme:\n    m.effort_sharing_common_level = Var(m.t, units=quant.unit(\"fraction_of_GDP\"))\n\n    constraints.extend(\n        [\n            # Total costs: mitigation + damage costs should be equal among regions as % GDP\n            RegionalSoftEqualityConstraint(\n                lambda m, t, r: m.rel_mitigation_costs[t, r]\n                + m.damage_costs[t, r]\n                + m.rel_financial_transfer[t, r],\n                lambda m, t, r: m.effort_sharing_common_level[t],\n                \"effort_sharing_regime_total_costs\",\n                ignore_if=lambda m, t, r: value(m.effort_sharing_regime)\n                != \"equal_total_costs\"\n                or m.year(t) &gt; 2100,\n            ),\n            # Mitigation costs: mitigation costs should be equal among regions as % GDP\n            RegionalSoftEqualityConstraint(\n                lambda m, t, r: m.rel_mitigation_costs[t, r],\n                lambda m, t, r: m.effort_sharing_common_level[t],\n                \"effort_sharing_regime_mitigation_costs\",\n                ignore_if=lambda m, t, r: value(m.effort_sharing_regime)\n                != \"equal_mitigation_costs\",\n                # or m.year(t) &gt; 2125,\n            ),\n        ]\n    )\n\n    ## Per capita convergence:\n    # m.regional_per_cap_emissions = Var(\n    #     m.t, m.regions, units=quant.unit(\"emissionsrate_unit/population_unit\")\n    # )\n    m.percapconv_share_init = Param(\n        m.regions,\n        initialize=lambda m, r: m.baseline_emissions[0, r]\n        / sum(m.baseline_emissions[0, s] for s in m.regions),\n    )\n    m.percapconv_year = Param(initialize=2050, doc=\"::effort sharing.percapconv_year\")\n    m.percapconv_share_pop = Param(\n        m.t,\n        m.regions,\n        initialize=lambda m, t, r: m.population[t, r]\n        / sum(m.population[t, s] for s in m.regions),\n    )\n\n    constraints.extend(\n        [\n            RegionalSoftEqualityConstraint(\n                lambda m, t, r: percapconv_share_rule(m, t, r) * m.global_emissions[t],\n                lambda m, t, r: m.baseline[t, r] - m.paid_for_emission_reductions[t, r],\n                epsilon=None,\n                absolute_epsilon=0.01,\n                ignore_if=lambda m, t, r: value(m.effort_sharing_regime)\n                != \"per_cap_convergence\"\n                or t == 0,\n                name=\"percapconv_rule\",\n            ),\n        ]\n    )\n\n    return constraints\n</code></pre>"},{"location":"components/emissions/","title":"Emissions and temperature","text":"<p> Back to general structure</p>  Baseline and mitigated emissions Temperature Carbon budget, inertia and other restrictions <p>The global temperature change is calculated as a linear function of cumulative emissions, with a slope given by the Transient Climate Response to CO<sub>2</sub> Emissions (TCRE), following [Dietz et al.] who showed that this performed better than the default two-box DICE climate module.</p> \\[ \\text{temperature}_{t} = T_0 + \\text{TCRE} \\cdot \\text{cumulative emissions}_{t}, \\] <p>where \\(T_0\\) is the initial temperature at the start of the run (by default in 2020), and the TCRE is the Transient Climate Response to CO<sub>2</sub> Emissions.</p> <p>The initial temperature is set to 1.16\u00b0C in 2020 by default, following [Visser et al.]. The TCRE is calibrated on the IPCC AR5 or AR6 reports (the median value of the TCRE is the same in the AR5 and AR6 calibration), but the distribution is different.</p> Calibration of the TCRE <p>The TCRE is calibrated on the IPCC AR5 and AR6 reports, both using the linear relation shown in the SPM figure of the WG1 report. The default value of the TCRE is 0.62\u00b0C per 1000 GtCO<sub>2</sub> (median value of the AR5 and AR6 calibration). The 5th and 95th percentiles differ between the two calibrations, with the AR5 calibration having a wider distribution:</p> Percentile AR5 TCRE (\u00b0C per TtCO<sub>2</sub>) AR6 TCRE (\u00b0C per TtCO<sub>2</sub>) 5th 0.42 0.42 50th 0.62 0.62 <code>default</code> 95th 0.82 0.75 Calibrated on IPCC AR5Calibrated on IPCC AR6 <p>  Source: IPCC AR5 WG1 Figure SPM.10</p> <p> </p> <p>Source: IPCC AR6 WG1 Figure SPM.10</p> <p>MIMOSA allows several types of constraints on emissions: a global carbon budget, inertia constraints, limits on net negative emissions and constraints on emissions after 2100.</p> Source code in <code>mimosa/components/emissions.py</code> <pre><code>def get_constraints(m: AbstractModel) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n\n    === \":octicons-cloud-24: Baseline and mitigated emissions\"\n\n        :::mimosa.components.emissions._get_emissions_constraints\n\n    === \":fontawesome-solid-temperature-half: Temperature\"\n\n        :::mimosa.components.emissions._get_temperature_constraints\n\n    === \":fontawesome-solid-chart-pie: Carbon budget, inertia and other restrictions\"\n\n        :::mimosa.components.emissions._get_inertia_and_budget_constraints\n\n    \"\"\"\n\n    # First set baseline emission functions (cumulative emissions and global cumulative emissions)\n    _set_baseline_emissions(m)\n\n    constraints = (\n        _get_emissions_constraints(m)\n        + _get_temperature_constraints(m)\n        + _get_inertia_and_budget_constraints(m)\n    )\n\n    return constraints\n</code></pre>"},{"location":"components/emissions/#mimosa.components.emissions._get_emissions_constraints--baseline-emissions","title":"Baseline emissions","text":"<p>In MIMOSA, emissions are represented by CO<sub>2</sub> emissions only<sup>1</sup>. The emissions are calculated relative to baseline emissions: emissions that would occur in the absence of any climate policy.</p> <p>There are two ways to calculate baseline emissions: either directly imported exogenously from the SSP scenarios, or calculated from the baseline carbon intensity from the SSPs. The latter accounts for the fact that in the absence of climate policy, baseline emissions would go down if the GDP goes down, and vice versa. This can be chosen with the parameter <code>use_baseline_carbon_intensity</code>. If this parameter is set to true, baseline emissions are calculated as:</p> \\[ \\text{baseline emissions}_{t,r} = \\text{baseline carbon intensity}_{t,r} \\cdot \\text{GDP}_{\\text{net}, t,r} \\] Baseline emissions values <p> </p>"},{"location":"components/emissions/#mimosa.components.emissions._get_emissions_constraints--emission-reductions","title":"Emission reductions","text":"<p>To calculate the actual emissions per region, the baseline emissions are reduced by a relative abatement factor, which in term is determined by the Marginal Abatement Cost curve and the carbon price (see Mitigation). The regional emissions are then calculated as:</p> \\[ \\text{regional emissions}_{t,r} = (1 - \\text{relative abatement}_{t,r}) \\cdot \\text{baseline emissions}_{t,r} \\] <p>In the first period, reductions are assumed to be zero:</p> \\[ \\text{regional emissions}_{0,r} = \\text{baseline emissions}_{0,r}. \\]"},{"location":"components/emissions/#mimosa.components.emissions._get_emissions_constraints--global-and-cumulative-emissions","title":"Global and cumulative emissions","text":"<p>The regional emissions are aggregated to global emissions:</p> \\[ \\text{global emissions}_{t} = \\sum_r \\text{regional emissions}_{t,r}, \\] <p>which are used to calculate the cumulative emissions. There are two ways to calculate them: using trapezoidal integration or by simply adding up all the years. The former is more accurate, while the latter is numerically more stable. This is chosen with the parameter <code>cumulative_emissions_trapz</code>.</p> Trapezoidal integration <code>default</code>Simple sum \\[ \\begin{aligned} \\text{cumulative emissions}_{t} &amp; = \\text{cumulative emissions}_{t-1} \\\\  &amp; + \\frac{\\Delta t}{2} \\cdot (\\text{global emissions}_{t} + \\text{global emissions}_{t-1}) ,\\text{for } t &gt; 0. \\end{aligned} \\] \\[ \\text{cumulative emissions}_{t} = \\text{cumulative emissions}_{t-1} + \\Delta t \\cdot \\text{global emissions}_{t} \\]"},{"location":"components/emissions/#mimosa.components.emissions._get_emissions_constraints--parameters-defined-in-this-module","title":"Parameters defined in this module","text":"<ul> <li><code>use_carbon_intensity_for_baseline</code>: If true, use baseline carbon intensity to calculate baseline emissions. If false, the SSP baseline emissions are used, regardless of lower GDP.. Type: bool. Default: True.</li> <li><code>cumulative_emissions_trapz</code>: If true, calculate cumulative emissions using trapezoidal interpolation. If false, cum. emissions are simply cum_emissions[t-1] + dt * cum_emissions[t]. This is less accurate, but better for numerical stability. For small dt the  approximation is usually still acceptable.. Type: bool. Default: True.</li> </ul> <ol> <li> <p>The effect of other greenhouse gases is implicitly accounted for in the TCRE which translates cumulative CO<sub>2</sub> emissions into temperature change. This assumes a linear relation between CO<sub>2</sub> emissions and other greenhouse gases.\u00a0\u21a9</p> </li> </ol> Source code in <code>mimosa/components/emissions.py</code> <pre><code>def _get_emissions_constraints(m: AbstractModel) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n    ## Baseline emissions\n\n    In MIMOSA, emissions are represented by CO&lt;sub&gt;2&lt;/sub&gt; emissions only[^1]. The emissions are calculated\n    relative to baseline emissions: emissions that would occur in the absence of any climate policy.\n\n    There are two ways to calculate baseline emissions: either directly imported exogenously from\n    the SSP scenarios, or calculated from the baseline carbon intensity from the SSPs. The latter\n    accounts for the fact that in the absence of climate policy, baseline emissions would go down if\n    the GDP goes down, and vice versa. This can be chosen with the parameter [`use_baseline_carbon_intensity`](../parameters.md#emissions.baseline carbon intensity).\n    If this parameter is set to true, baseline emissions are calculated as:\n\n    $$\n    \\\\text{baseline emissions}_{t,r} = \\\\text{baseline carbon intensity}_{t,r} \\\\cdot \\\\text{GDP}_{\\\\text{net}, t,r}\n    $$\n\n    ??? info \"Baseline emissions values\"\n\n        &lt;div style=\"overflow: scroll;\" markdown&gt;\n        ``` plotly\n        {\"file_path\": \"./assets/plots/baseline_emissions.json\"}\n        ```\n        &lt;/div&gt;\n\n    ## Emission reductions\n    To calculate the actual emissions per region, the baseline emissions are reduced by a relative\n    abatement factor, which in term is determined by the Marginal Abatement Cost curve and the carbon price\n    (see [Mitigation](mitigation.md)). The regional emissions are then calculated as:\n\n    $$\n    \\\\text{regional emissions}_{t,r} = (1 - \\\\text{relative abatement}_{t,r}) \\\\cdot \\\\text{baseline emissions}_{t,r}\n    $$\n\n    In the first period, reductions are assumed to be zero:\n\n    $$\n    \\\\text{regional emissions}_{0,r} = \\\\text{baseline emissions}_{0,r}.\n    $$\n\n    ## Global and cumulative emissions\n\n    The regional emissions are aggregated to global emissions:\n\n    $$\n    \\\\text{global emissions}_{t} = \\\\sum_r \\\\text{regional emissions}_{t,r},\n    $$\n\n    which are used to calculate the cumulative emissions. There are two ways to calculate them:\n    using trapezoidal integration or by simply adding up all the years. The former is more accurate,\n    while the latter is numerically more stable. This is chosen with the parameter [`cumulative_emissions_trapz`](../parameters.md#emissions.cumulative_emissions_trapz).\n\n    === \"Trapezoidal integration `default`\"\n\n        $$\n        \\\\begin{aligned}\n        \\\\text{cumulative emissions}_{t} &amp; = \\\\text{cumulative emissions}_{t-1} \\\\\\\\ \n        &amp; + \\\\frac{\\\\Delta t}{2} \\\\cdot (\\\\text{global emissions}_{t} + \\\\text{global emissions}_{t-1}) ,\\\\text{for } t &gt; 0.\n        \\\\end{aligned}\n        $$\n\n    === \"Simple sum\"\n\n        $$\n        \\\\text{cumulative emissions}_{t} = \\\\text{cumulative emissions}_{t-1} + \\\\Delta t \\\\cdot \\\\text{global emissions}_{t}\n        $$\n\n\n    ## Parameters defined in this module\n    - <code>use_carbon_intensity_for_baseline</code>: If true, use baseline carbon intensity to calculate baseline emissions. If false, the SSP baseline emissions are used, regardless of lower GDP.. Type: bool. Default: True.\n    - <code>cumulative_emissions_trapz</code>: If true, calculate cumulative emissions using trapezoidal interpolation. If false, cum. emissions are simply cum_emissions[t-1] + dt * cum_emissions[t]. This is less accurate, but better for numerical stability. For small dt the  approximation is usually still acceptable.. Type: bool. Default: True.\n\n    [^1]: The effect of other greenhouse gases is implicitly accounted for in the TCRE which\n        translates cumulative CO&lt;sub&gt;2&lt;/sub&gt; emissions into temperature change. This assumes a linear\n        relation between CO&lt;sub&gt;2&lt;/sub&gt; emissions and other greenhouse gases.\n    \"\"\"\n\n    constraints = []\n\n    m.regional_emissions = Var(m.t, m.regions, units=quant.unit(\"emissionsrate_unit\"))\n    m.baseline = Var(\n        m.t,\n        m.regions,\n        initialize=lambda m, t, r: m.baseline_emissions[t, r],\n        units=quant.unit(\"emissionsrate_unit\"),\n    )\n    m.use_carbon_intensity_for_baseline = Param(\n        doc=\"::emissions.baseline carbon intensity\"\n    )\n\n    m.relative_abatement = Var(\n        m.t,\n        m.regions,\n        initialize=0,\n        bounds=(0, 2.5),\n        units=quant.unit(\"fraction_of_baseline_emissions\"),\n    )\n    m.regional_emission_reduction = Var(\n        m.t, m.regions, units=quant.unit(\"emissionsrate_unit\")\n    )\n    m.cumulative_emissions = Var(m.t, units=quant.unit(\"emissions_unit\"))\n    m.global_emissions = Var(m.t, units=quant.unit(\"emissionsrate_unit\"))\n\n    m.cumulative_emissions_trapz = Param(doc=\"::emissions.cumulative_emissions_trapz\")\n\n    constraints.extend(\n        [\n            # Baseline emissions based on emissions or carbon intensity\n            RegionalConstraint(\n                lambda m, t, r: (\n                    (\n                        m.baseline[t, r]\n                        == m.baseline_carbon_intensity[t, r] * m.GDP_net[t, r]\n                    )\n                    if value(m.use_carbon_intensity_for_baseline)\n                    else (m.baseline[t, r] == m.baseline_emissions[t, r])\n                ),\n                name=\"baseline_emissions\",\n            ),\n            # Regional emissions from baseline and relative abatement\n            RegionalConstraint(\n                lambda m, t, r: (\n                    m.regional_emissions[t, r]\n                    == (1 - m.relative_abatement[t, r])\n                    * (\n                        m.baseline[t, r]\n                        if value(m.use_carbon_intensity_for_baseline)\n                        else m.baseline_emissions[t, r]\n                        # Note: this should simply be m.baseline[t,r], but this is numerically less stable\n                        # than m.baseline_emissions[t, r] whenever baseline intensity\n                        # is used instead of baseline emissions. In fact, m.baseline_emissions[t, r]\n                        # is just a fixed number, whereas m.baseline[t,r] is a variable depending on\n                        # GDP.\n                    )\n                    if t &gt; 0\n                    else Constraint.Skip\n                ),\n                \"regional_abatement\",\n            ),\n            RegionalInitConstraint(\n                lambda m, r: m.regional_emissions[0, r] == m.baseline_emissions[0, r]\n            ),\n            RegionalConstraint(\n                lambda m, t, r: m.regional_emission_reduction[t, r]\n                == m.baseline[t, r] - m.regional_emissions[t, r],\n                \"regional_emission_reduction\",\n            ),\n            # Global emissions (sum from regional emissions)\n            GlobalConstraint(\n                lambda m, t: (\n                    m.global_emissions[t]\n                    == sum(m.regional_emissions[t, r] for r in m.regions)\n                    if t &gt; 0\n                    else Constraint.Skip\n                ),\n                \"global_emissions\",\n            ),\n            GlobalInitConstraint(\n                lambda m: m.global_emissions[0]\n                == sum(m.baseline_emissions[0, r] for r in m.regions),\n                \"global_emissions_init\",\n            ),\n            # Cumulative global emissions\n            GlobalConstraint(\n                lambda m, t: (\n                    m.cumulative_emissions[t]\n                    == m.cumulative_emissions[t - 1]\n                    + (\n                        (m.dt * (m.global_emissions[t] + m.global_emissions[t - 1]) / 2)\n                        if value(m.cumulative_emissions_trapz)\n                        else (m.dt * m.global_emissions[t])\n                    )\n                    if t &gt; 0\n                    else Constraint.Skip\n                ),\n                \"cumulative_emissions\",\n            ),\n            GlobalInitConstraint(lambda m: m.cumulative_emissions[0] == 0),\n        ]\n    )\n\n    m.emission_relative_cumulative = Var(m.t, initialize=1)\n    constraints.extend(\n        [\n            GlobalConstraint(\n                lambda m, t: (\n                    (\n                        m.emission_relative_cumulative[t]\n                        == m.cumulative_emissions[t]\n                        / m.cumulative_global_baseline_emissions[t]\n                    )\n                    if t &gt; 0\n                    else Constraint.Skip\n                ),\n                name=\"relative_cumulative_emissions\",\n            ),\n            GlobalInitConstraint(lambda m: m.emission_relative_cumulative[0] == 1),\n        ]\n    )\n\n    return constraints\n</code></pre>"},{"location":"components/emissions/#mimosa.components.emissions._get_temperature_constraints--temperature-target","title":"Temperature target","text":"<p>The usual way to specify a policy target in MIMOSA is using carbon budgets. However, it is also possible to specify a temperature target. This is done by setting the parameter <code>temperature_target</code>. This is an upper bound on the temperature: if the cost-optimal temperature is below this value, this constraint is not binding.</p> <p>If this parameter is set, the following constraint is active:</p> \\[ \\text{temperature}_{t} \\leq \\text{temperature target} \\]"},{"location":"components/emissions/#mimosa.components.emissions._get_temperature_constraints--parameters-defined-in-this-module","title":"Parameters defined in this module","text":"<ul> <li><code>T0</code>: Temperature in initial year of model run (2020 by default).. Type: quantity. Default: 1.16 delta_degC. Unit: temperature_unit.</li> <li><code>TCRE</code>: Transient Climate Response to CO2 Emissions. Type: quantity. Default: 0.62 delta_degC/(TtCO2). Unit: (temperature_unit)/(emissions_unit).</li> <li><code>temperature_target</code>: Temperature target in 2100 (and beyond). Can also be false, then no temperature target is imposed. Type: quantity. Default: False. Can also be false. Unit: temperature_unit.</li> </ul> Source code in <code>mimosa/components/emissions.py</code> <pre><code>def _get_temperature_constraints(m: AbstractModel) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n\n    The global temperature change is calculated as a linear function of cumulative emissions, with a slope\n    given by the Transient Climate Response to CO&lt;sub&gt;2&lt;/sub&gt; Emissions (TCRE), following [Dietz et al.] who\n    showed that this performed better than the default two-box DICE climate module.\n\n    $$\n    \\\\text{temperature}_{t} = T_0 + \\\\text{TCRE} \\\\cdot \\\\text{cumulative emissions}_{t},\n    $$\n\n    where [$T_0$](../parameters.md#temperature.initial) is the initial temperature at the start of the run (by default in 2020),\n    and the [TCRE](../parameters.md#temperature.TCRE) is the Transient Climate Response to CO&lt;sub&gt;2&lt;/sub&gt; Emissions.\n\n    The initial temperature is set to 1.16\u00b0C in 2020 by default, following [Visser et al.]. The TCRE\n    is calibrated on the IPCC AR5 or AR6 reports (the median value of the TCRE is the same in the AR5\n    and AR6 calibration), but the distribution is different.\n\n    ??? info \"Calibration of the TCRE\"\n\n        The TCRE is calibrated on the IPCC AR5 and AR6 reports, both using the linear relation shown in the SPM figure of the WG1 report.\n        The default value of the TCRE is 0.62\u00b0C per 1000 GtCO&lt;sub&gt;2&lt;/sub&gt; (median value of the AR5 and AR6 calibration). The 5th and 95th percentiles\n        differ between the two calibrations, with the AR5 calibration having a wider distribution:\n\n        | Percentile | AR5 TCRE &lt;br&gt;&lt;span style=\"font-weight: normal\"&gt;(\u00b0C per TtCO&lt;sub&gt;2&lt;/sub&gt;)&lt;/span&gt; | AR6 TCRE &lt;br&gt;&lt;span style=\"font-weight: normal\"&gt;(\u00b0C per TtCO&lt;sub&gt;2&lt;/sub&gt;)&lt;/span&gt; |\n        |------------|----------|----------|\n        | 5th        | 0.42     | 0.42     |\n        | 50th       | 0.62     | 0.62 `default` |\n        | 95th       | 0.82     | 0.75     |\n\n        === \"Calibrated on IPCC AR5\"\n\n            &lt;div style=\"overflow: scroll;\" markdown&gt;\n            ``` plotly\n            {\"file_path\": \"./assets/plots/ar5_tcre.json\"}\n            ```\n            &lt;/div&gt;\n            Source: [IPCC AR5 WG1 Figure SPM.10](https://www.ipcc.ch/report/ar5/wg1/summary-for-policymakers/figspm-10/)\n\n        === \"Calibrated on IPCC AR6\"\n\n            &lt;div style=\"overflow: scroll;\" markdown&gt;\n            ``` plotly\n            {\"file_path\": \"./assets/plots/ar6_tcre.json\"}\n            ```\n            &lt;/div&gt;\n\n            Source: [IPCC AR6 WG1 Figure SPM.10](https://www.ipcc.ch/report/ar6/wg1/figures/summary-for-policymakers/figure-spm-10)\n\n    ## Temperature target\n    The usual way to specify a policy target in MIMOSA is using carbon budgets. However, it is also possible to\n    specify a temperature target. This is done by setting the parameter [`temperature_target`](../parameters.md#temperature.target).\n    This is an upper bound on the temperature: if the cost-optimal temperature is below this value, this constraint is not binding.\n\n    If this parameter is set, the following constraint is active:\n\n    $$\n    \\\\text{temperature}_{t} \\\\leq \\\\text{temperature target}\n    $$\n\n    ## Parameters defined in this module\n    - <code>T0</code>: Temperature in initial year of model run (2020 by default).. Type: quantity. Default: 1.16 delta_degC. Unit: temperature_unit.\n    - <code>TCRE</code>: Transient Climate Response to CO2 Emissions. Type: quantity. Default: 0.62 delta_degC/(TtCO2). Unit: (temperature_unit)/(emissions_unit).\n    - <code>temperature_target</code>: Temperature target in 2100 (and beyond). Can also be false, then no temperature target is imposed. Type: quantity. Default: False. Can also be false. Unit: temperature_unit.\n    \"\"\"\n\n    constraints = []\n\n    m.T0 = Param(units=quant.unit(\"degC_above_PI\"), doc=\"::temperature.initial\")\n    m.temperature = Var(\n        m.t, initialize=lambda m, t: m.T0, units=quant.unit(\"degC_above_PI\")\n    )\n    m.TCRE = Param(doc=\"::temperature.TCRE\")\n    m.temperature_target = Param(doc=\"::temperature.target\")\n    constraints.extend(\n        [\n            GlobalConstraint(\n                lambda m, t: m.temperature[t]\n                == m.T0 + m.TCRE * m.cumulative_emissions[t],\n                \"temperature\",\n            ),\n            GlobalInitConstraint(lambda m: m.temperature[0] == m.T0),\n            GlobalConstraint(\n                lambda m, t: (\n                    m.temperature[t] &lt;= m.temperature_target\n                    if (m.year(t) &gt;= 2100 and value(m.temperature_target) is not False)\n                    else Constraint.Skip\n                ),\n                name=\"temperature_target\",\n            ),\n        ]\n    )\n\n    m.perc_reversible_damages = Param(doc=\"::economics.damages.percentage reversible\")\n\n    # m.overshoot = Var(m.t, initialize=0)\n    # m.overshootdot = DerivativeVar(m.overshoot, wrt=m.t)\n    # m.netnegative_emissions = Var(m.t)\n    # global_constraints.extend(\n    #     [\n    #         lambda m, t: m.netnegative_emissions[t]\n    #         == m.global_emissions[t] * (1 - tanh(m.global_emissions[t] * 10)) / 2\n    #         if value(m.perc_reversible_damages) &lt; 1\n    #         else Constraint.Skip,\n    #         lambda m, t: m.overshootdot[t]\n    #         == (m.netnegative_emissions[t] if t &lt;= value(m.year2100) and t &gt; 0 else 0)\n    #         if value(m.perc_reversible_damages) &lt; 1\n    #         else Constraint.Skip,\n    #     ]\n    # )\n\n    # global_constraints_init.extend([lambda m: m.overshoot[0] == 0])\n\n    return constraints\n</code></pre>"},{"location":"components/emissions/#mimosa.components.emissions._get_inertia_and_budget_constraints--carbon-budget","title":"Carbon budget","text":"<p>By default, the carbon budget is set to <code>False</code>, which means that MIMOSA runs in CBA mode without carbon budget. If a carbon budget is defined using the parameter <code>carbonbudget</code>, the following constraint is active:</p> \\[ \\text{cumulative emissions}_{t} - \\text{budget} \\leq 0, \\] <p>for \\(t \\geq 2100\\). Note that the <code>carbonbudget</code> parameter unit should be in GtCO<sub>2</sub> (or TtCO<sub>2</sub> or MtCO<sub>2</sub>).</p>"},{"location":"components/emissions/#mimosa.components.emissions._get_inertia_and_budget_constraints--inertia","title":"Inertia","text":"<p>In MIMOSA, there is a limit on how fast emissions can be reduced. This constraint is called inertia, and represents the technological, social, political and economic difficulties of quickly reducing emissions. It is implemented as a hard limit on the speed of emission reductions. The parameters <code>inertia_global</code> and <code>inertia_regional</code> are defined as percentages of baseline emissions in the initial year. If baseline emissions in a region are 10 GtCO<sub>2</sub>/yr in the initial year, and the global inertia is 5%, then the global emissions cannot be reduced by more than 0.5 GtCO<sub>2</sub>/yr throughout the whole run. This way, the parameter is independent of the size of the region.</p> Global inertiaRegional inertia \\[ \\text{global emissions}_{t} - \\text{global emissions}_{t-1} \\geq \\Delta t \\cdot \\text{inertia_global} \\cdot \\text{scaling factor}, \\] <p>with the scaling factor the global baseline emissions in the starting year:</p> \\[ \\text{scaling factor} = \\left( \\sum_r \\text{baseline emissions}_{t=0,r}\\right) \\] <p>By default, the <code>inertia_global</code> is set to <code>False</code>, such that there is no global inertia constraint. The only inertia constraint happens regionally by default.</p> \\[ \\text{regional emissions}_{t,r} - \\text{regional emissions}_{t-1,r} \\geq \\Delta t \\cdot \\text{inertia_regional} \\cdot \\text{baseline emissions}_{t=0,r}. \\] <p>By default, the <code>inertia_regional</code> parameter is active, such that regional emissions cannot be reduced by more than 5% of the initial baseline emissions per year. This is based on maximum reduction speeds of the scenarios in the scenario explorer for 1.5\u00b0C pathways underpinning the IPCC Special Report on Global Warming of 1.5\u00b0C (https://data.ene.iiasa.ac.at/iamc-1.5c-explorer) (ref https://www.frontiersin.org/articles/10.3389/fclim.2021.785577/full)</p>"},{"location":"components/emissions/#mimosa.components.emissions._get_inertia_and_budget_constraints--minimum-emission-levels-limits-to-net-negative-emissions","title":"Minimum emission levels (limits to net-negative emissions)","text":"<p>Since the Marginal Abatement Cost curve is a continuous function with no upper bound, reductions can theoretically be without bound. To still address the difficulties associated with CDR technologies, a limit on (net) negative emissions can be imposed. These difficulties can be of economic (e.g., land becoming increasingly scarce or increased dependence on very expensive storage sites) and socio-political (concerns about biodiversity and food security) nature (TODO ref Hotelling-Hof-Wijst paper and Fuss et al.). By the default, the global emissions are limited to -20 GtCO<sub>2</sub>/yr, and regionally to -10 GtCO<sub>2</sub>:</p> \\[ \\text{global emissions}_t \\geq \\text{global min level}, \\] \\[ \\text{regional emissions}_t \\geq \\text{regional min level}. \\] <p>Note that currently, the minimum regional emission level is the same for every region, but this could be easily changed if needed (see Extending MIMOSA).</p>"},{"location":"components/emissions/#mimosa.components.emissions._get_inertia_and_budget_constraints--constraints-on-emissions-after-2100","title":"Constraints on emissions after 2100","text":"<p>In CBA mode, it can be useful to run MIMOSA until 2150 instead of 2100, to avoid end-of-horizon effects. One way to mitigate this effect is to impose a constraint on the growth of emissions after 2100. By default, emissions are not allowed to grow after 2100:</p> \\[ \\text{regional emissions}_{t,r} - \\text{regional emissions}_{t-1,r} \\leq 0, \\text{if } t - 1 &gt; 2100, \\] <p>if the parameter <code>non_increasing_emissions_after_2100</code> is set to <code>True</code>.</p> <p>When a carbon budget is imposed, it is also possible to impose a net-zero emissions constraint after the budget year (2100):</p> <p>$$ \\text{global emissions}_{t} \\leq 0, \\text{if } t \\geq 2100, $$ if the parameter <code>no_pos_emissions_after_budget_year</code> is set to <code>True</code>, and if a carbon budget is specified. Otherwise, this constraint is ignored.</p>"},{"location":"components/emissions/#mimosa.components.emissions._get_inertia_and_budget_constraints--parameters-defined-in-this-module","title":"Parameters defined in this module","text":"<ul> <li><code>budget</code>: Value of the carbon budget. Example: \"800 GtCO2\" (the unit is important). If set to False, no carbon budget is imposed: this is cost-benefit mode. Default: False.. Type: quantity. Default: False. Can also be false. Unit: emissions_unit.</li> <li><code>inertia_global</code>: Maximum reduction speed, in % of initial emissions (should be negative) Can also be false, then no inertia limit is imposed. Type: float. Default: False. Can also be false. Min: -inf. Max: 0.</li> <li><code>inertia_regional</code>: Maximum reduction speed, in % of initial emissions (should be negative) Can also be false, then no inertia limit is imposed. Type: float. Default: -0.05. Can also be false. Min: -inf. Max: 0.</li> <li><code>global_min_level</code>: Limit on the emission level (globally), mostly used for negative emissions. Can also be false, then no limit is imposed. Type: quantity. Default: -20 GtCO2/yr. Can also be false. Unit: emissionsrate_unit.</li> <li><code>regional_min_level</code>: Limit on the emission level (per region), mostly used for negative emissions. Can also be false, then no limit is imposed. Type: quantity. Default: -10 GtCO2/yr. Can also be false. Unit: emissionsrate_unit.</li> <li><code>no_pos_emissions_after_budget_year</code>: If true, impose net-zero emissions after budget year (2100). Type: bool. Default: True.</li> <li><code>non_increasing_emissions_after_2100</code>: If true, the regional emissions after 2100 are not allowed to climb.. Type: bool. Default: True.</li> </ul> Source code in <code>mimosa/components/emissions.py</code> <pre><code>def _get_inertia_and_budget_constraints(\n    m: AbstractModel,\n) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n    MIMOSA allows several types of constraints on emissions: a global carbon budget, inertia constraints,\n    limits on net negative emissions and constraints on emissions after 2100.\n\n    ## Carbon budget\n\n    By default, the carbon budget is set to `False`, which means that MIMOSA runs in CBA mode without carbon budget.\n    If a carbon budget is defined using the parameter [`carbonbudget`](../parameters.md#emissions.carbonbudget), the following constraint is active:\n\n    $$\n    \\\\text{cumulative emissions}_{t} - \\\\text{budget} \\\\leq 0,\n    $$\n\n    for $t \\\\geq 2100$. Note that the [`carbonbudget`](../parameters.md#emissions.carbonbudget) parameter unit should be\n    in GtCO&lt;sub&gt;2&lt;/sub&gt; (or TtCO&lt;sub&gt;2&lt;/sub&gt; or MtCO&lt;sub&gt;2&lt;/sub&gt;).\n\n    ## Inertia\n\n    In MIMOSA, there is a limit on how fast emissions can be reduced. This constraint is called inertia, and represents the\n    technological, social, political and economic difficulties of quickly reducing emissions. It is implemented as a hard limit\n    on the speed of emission reductions. The parameters [`inertia_global`](../parameters.md#emissions.inertia.global) and\n    [`inertia_regional`](../parameters.md#emissions.inertia.regional) are defined as percentages of baseline emissions in the\n    initial year. If baseline emissions in a region are 10 GtCO&lt;sub&gt;2&lt;/sub&gt;/yr in the initial year, and the global inertia is 5%,\n    then the global emissions cannot be reduced by more than 0.5 GtCO&lt;sub&gt;2&lt;/sub&gt;/yr throughout the whole run. This way, the parameter\n    is independent of the size of the region.\n\n    === \"Global inertia\"\n\n\n        $$\n        \\\\text{global emissions}_{t} - \\\\text{global emissions}_{t-1} \\\\geq \\\\Delta t \\\\cdot \\\\text{inertia_global} \\\\cdot \\\\text{scaling factor},\n        $$\n\n        with the scaling factor the global baseline emissions in the starting year:\n\n        $$\n        \\\\text{scaling factor} = \\\\left( \\\\sum_r \\\\text{baseline emissions}_{t=0,r}\\\\right)\n        $$\n\n        By default, the [`inertia_global`](../parameters.md#emissions.inertia.global) is set to `False`, such that there is no global inertia\n        constraint. The only inertia constraint happens regionally by default.\n\n    === \"Regional inertia\"\n\n        $$\n        \\\\text{regional emissions}_{t,r} - \\\\text{regional emissions}_{t-1,r} \\\\geq \\\\Delta t \\\\cdot \\\\text{inertia_regional} \\\\cdot \\\\text{baseline emissions}_{t=0,r}.\n        $$\n\n        By default, the [`inertia_regional`](../parameters.md#emissions.inertia.regional) parameter is active, such that regional emissions cannot be reduced by more than 5% of the initial baseline emissions per year. This is\n        based on maximum reduction speeds of the scenarios in the scenario explorer for 1.5\u00b0C pathways underpinning the IPCC Special Report on Global Warming\n        of 1.5\u00b0C (&lt;https://data.ene.iiasa.ac.at/iamc-1.5c-explorer&gt;) (ref https://www.frontiersin.org/articles/10.3389/fclim.2021.785577/full)\n\n\n    ## Minimum emission levels (limits to net-negative emissions)\n\n    Since the Marginal Abatement Cost curve is a continuous function with no upper bound, reductions can theoretically be without bound.\n    To still address the difficulties associated with CDR technologies, a limit on (net) negative emissions can be imposed. These difficulties\n    can be of economic (e.g., land becoming increasingly scarce or increased dependence on very expensive storage sites) and socio-political\n    (concerns about biodiversity and food security) nature (TODO ref Hotelling-Hof-Wijst paper and Fuss et al.). By the default, the global emissions\n    are limited to -20 GtCO&lt;sub&gt;2&lt;/sub&gt;/yr, and regionally to -10 GtCO&lt;sub&gt;2&lt;/sub&gt;:\n\n    $$\n    \\\\text{global emissions}_t \\\\geq \\\\text{global min level},\n    $$\n\n    $$\n    \\\\text{regional emissions}_t \\\\geq \\\\text{regional min level}.\n    $$\n\n    Note that currently, the minimum regional emission level is the same for every region, but this could be easily changed if needed (see\n    [Extending MIMOSA](../extending/index.md)).\n\n    ## Constraints on emissions after 2100\n\n    In CBA mode, it can be useful to run MIMOSA until 2150 instead of 2100, to avoid end-of-horizon effects. One way to mitigate\n    this effect is to impose a constraint on the growth of emissions after 2100. By default, emissions are not allowed to grow after 2100:\n\n    $$\n    \\\\text{regional emissions}_{t,r} - \\\\text{regional emissions}_{t-1,r} \\\\leq 0, \\\\text{if } t - 1 &gt; 2100,\n    $$\n\n    if the parameter [`non_increasing_emissions_after_2100`](../parameters.md#emissions.non increasing emissions after 2100) is set to `True`.\n\n    When a carbon budget is imposed, it is also possible to impose a net-zero emissions constraint after the budget year (2100):\n\n    $$\n    \\\\text{global emissions}_{t} \\\\leq 0, \\\\text{if } t \\\\geq 2100,\n    $$\n    if the parameter [`no_pos_emissions_after_budget_year`](../parameters.md#emissions.not positive after budget year) is set to `True`,\n    **and** if a carbon budget is specified. Otherwise, this constraint is ignored.\n\n\n    ## Parameters defined in this module\n    - <code>budget</code>: Value of the carbon budget. Example: \"800 GtCO2\" (the unit is important). If set to False, no carbon budget is imposed: this is cost-benefit mode. Default: False.. Type: quantity. Default: False. Can also be false. Unit: emissions_unit.\n    - <code>inertia_global</code>: Maximum reduction speed, in % of initial emissions (should be negative) Can also be false, then no inertia limit is imposed. Type: float. Default: False. Can also be false. Min: -inf. Max: 0.\n    - <code>inertia_regional</code>: Maximum reduction speed, in % of initial emissions (should be negative) Can also be false, then no inertia limit is imposed. Type: float. Default: -0.05. Can also be false. Min: -inf. Max: 0.\n    - <code>global_min_level</code>: Limit on the emission level (globally), mostly used for negative emissions. Can also be false, then no limit is imposed. Type: quantity. Default: -20 GtCO2/yr. Can also be false. Unit: emissionsrate_unit.\n    - <code>regional_min_level</code>: Limit on the emission level (per region), mostly used for negative emissions. Can also be false, then no limit is imposed. Type: quantity. Default: -10 GtCO2/yr. Can also be false. Unit: emissionsrate_unit.\n    - <code>no_pos_emissions_after_budget_year</code>: If true, impose net-zero emissions after budget year (2100). Type: bool. Default: True.\n    - <code>non_increasing_emissions_after_2100</code>: If true, the regional emissions after 2100 are not allowed to climb.. Type: bool. Default: True.\n\n    \"\"\"\n\n    constraints = []\n\n    m.budget = Param(doc=\"::emissions.carbonbudget\")\n    m.inertia_global = Param(doc=\"::emissions.inertia.global\")\n    m.inertia_regional = Param(doc=\"::emissions.inertia.regional\")\n    m.global_min_level = Param(doc=\"::emissions.global min level\")\n    m.regional_min_level = Param(doc=\"::emissions.regional min level\")\n    m.non_increasing_emissions_after_2100 = Param(\n        doc=\"::emissions.non increasing emissions after 2100\"\n    )\n    m.no_pos_emissions_after_budget_year = Param(\n        doc=\"::emissions.not positive after budget year\"\n    )\n    constraints.extend(\n        [\n            # Carbon budget constraints:\n            GlobalConstraint(\n                lambda m, t: (\n                    m.cumulative_emissions[t]\n                    - (\n                        m.budget\n                        + (\n                            m.overshoot[t] * (1 - m.perc_reversible_damages)\n                            if value(m.perc_reversible_damages) &lt; 1\n                            else 0\n                        )\n                    )\n                    &lt;= 0\n                    if (m.year(t) &gt;= 2100 and value(m.budget) is not False)\n                    else Constraint.Skip\n                ),\n                name=\"carbon_budget\",\n            ),\n            GlobalConstraint(lambda m, t: m.cumulative_emissions[t] &gt;= 0),\n            # Global and regional inertia constraints:\n            GlobalConstraint(\n                lambda m, t: (\n                    m.global_emissions[t] - m.global_emissions[t - 1]\n                    &gt;= m.dt\n                    * m.inertia_global\n                    * sum(m.baseline_emissions[0, r] for r in m.regions)\n                    if value(m.inertia_global) is not False and t &gt; 0\n                    else Constraint.Skip\n                ),\n                name=\"global_inertia\",\n            ),\n            RegionalConstraint(\n                lambda m, t, r: (\n                    m.regional_emissions[t, r] - m.regional_emissions[t - 1, r]\n                    &gt;= m.dt * m.inertia_regional * m.baseline_emissions[0, r]\n                    if value(m.inertia_regional) is not False and t &gt; 0\n                    else Constraint.Skip\n                ),\n                name=\"regional_inertia\",\n            ),\n            GlobalConstraint(\n                lambda m, t: (\n                    m.global_emissions[t] &gt;= m.global_min_level\n                    if value(m.global_min_level) is not False\n                    else Constraint.Skip\n                ),\n                \"global_min_level\",\n            ),\n            RegionalConstraint(\n                lambda m, t, r: (\n                    m.regional_emissions[t, r] &gt;= m.regional_min_level\n                    if value(m.regional_min_level) is not False\n                    else Constraint.Skip\n                ),\n                \"regional_min_level\",\n            ),\n            RegionalConstraint(\n                lambda m, t, r: (\n                    m.regional_emissions[t, r] - m.regional_emissions[t - 1, r] &lt;= 0\n                    if m.year(t - 1) &gt; 2100\n                    and value(m.non_increasing_emissions_after_2100)\n                    else Constraint.Skip\n                ),\n                name=\"non_increasing_emissions_after_2100\",\n            ),\n            GlobalConstraint(\n                lambda m, t: (\n                    m.global_emissions[t] &lt;= 0\n                    if (\n                        m.year(t) &gt;= 2100\n                        and value(m.no_pos_emissions_after_budget_year) is True\n                        and value(m.budget) is not False\n                    )\n                    else Constraint.Skip\n                ),\n                name=\"net_zero_after_2100\",\n            ),\n        ]\n    )\n\n    return constraints\n</code></pre>"},{"location":"components/emissiontrading/","title":"Emission trading","text":"<p> Back to general structure</p> <p>TODO</p>"},{"location":"components/financialtransfers/","title":"Financial transfers","text":"<p> Back to general structure</p> <p>TODO</p>"},{"location":"components/mitigation/","title":"Mitigation","text":"<p> Back to general structure</p>  Marginal Abatement Costs (MAC) and mitigation costs Technological learning <p>In MIMOSA, the baseline emissions can be reduced by implementing a carbon price. This increases the price of carbon-intensive technologies relative to cleaner alternatives, which in turn leads to a reduction in emissions.</p> <p>In MIMOSA, there are two ways in which the price of mitigation policy can be reduced over time: through learning by doing and learning over time. The learning factor is the product of these two factors.</p> Source code in <code>mimosa/components/mitigation.py</code> <pre><code>def get_constraints(m: AbstractModel) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n\n    === \":material-chart-bell-curve-cumulative: Marginal Abatement Costs (MAC) and mitigation costs\"\n\n        :::mimosa.components.mitigation._get_mac_constraints\n\n    === \":material-solar-power-variant-outline: Technological learning\"\n\n        :::mimosa.components.mitigation._get_learning_constraints\n\n    \"\"\"\n    constraints = _get_mac_constraints(m) + _get_learning_constraints(m)\n\n    return constraints\n</code></pre>"},{"location":"components/mitigation/#mimosa.components.mitigation._get_mac_constraints--marginal-abatement-cost-curve","title":"Marginal Abatement Cost curve","text":"<p>The carbon price required to reach a certain level of emission reduction is quantified by a Marginal Abatement Cost curve (MAC curve) and gives instantaneous reductions (emission reductions in a given year) relative to the baseline emissions. First, a global MAC curve is defined, which is then scaled for every region to give the regional MAC curve.</p>"},{"location":"components/mitigation/#mimosa.components.mitigation._get_mac_constraints--global-mac-curve","title":"Global MAC curve","text":"<p>The global MAC curve is defined as function of the relative mitigation \\(a\\) (percentage reduction of emissions compared to baseline emissions) and a time-dependent learning factor:</p> \\[ \\text{MAC}_t(a) = \\left( \\gamma \\cdot a^{\\beta}\\right) \\cdot \\text{learning factor}_t. \\] <p>The parameters \\(\\gamma\\) (<code>MAC_gamma</code>) and \\(\\beta\\) (<code>MAC_beta</code>) are calibrated using the IPCC AR6 WG3 report. The learning factor depends on learning by doing and learning over time (see the tab \"Technological learning\").</p> Calibrating the MAC using the IPCC AR6 WG3 report"},{"location":"components/mitigation/#mimosa.components.mitigation._get_mac_constraints--step-1-calibration-data-source-ipcc-ar6","title":"Step 1: calibration data source: IPCC AR6","text":"<p>Specifically, Figure 3.34c from the WGIII full report has been used to calibrate the MAC, as it gives discounted consumption losses from mitigation as function of cumulative CO2 emissions. However, for this use, the figure has been slightly recreated as function of cumulative CO2 emsisions from 2020 to 2100, instead of cumulative CO2 emissions from 2020 to the year of net-zero, to give a more accurate representation of mitigation costs for scenarios that reach net zero. The resulting mitigation costs are:</p> <p>All costs are calculated as the NPV of GDP losses (as compared to the corresponding baseline GDP path for each scenario) with a fixed social discount rate of 3%/year, as used in the original IPCC AR6 figure.</p>"},{"location":"components/mitigation/#mimosa.components.mitigation._get_mac_constraints--step-2-fitting-a-function-to-the-data","title":"Step 2: fitting a function to the data","text":"<p>The next step is to fit a function through the cloud of points. We assume that the MAC is a power function (of a certain power \\(\\beta\\)). This means that the abatement costs, being the integral of the MAC (area under the MAC) follows a function of power \\(\\beta+1\\). We obtain the best fit (highest r-squared) with a power of \\(\\beta=3\\), so a cubic MAC. We then perform an Ordinary Least Square regression of the function \\(a \\cdot x^4\\) (a power function of \\(\\beta+1=4\\)) and obtain the best fit shown as solid black line in figure 1:</p> <p></p> <p>Source of underlying GDP losses: IPCC AR6 WG3 Figure 3.34</p>"},{"location":"components/mitigation/#mimosa.components.mitigation._get_mac_constraints--step-3-calibrating-mimosa-to-the-fitted-function","title":"Step 3: calibrating MIMOSA to the fitted function","text":"<p>The final step is to calibrate the MAC used in MIMOSA to the OLS fit. In MIMOSA, this means calibrating the parameter \\(\\gamma\\). When using</p> \\[\\gamma = 2601 \\text{ \\$/tCO}_2,\\] <p>the MIMOSA costs align best with the OLS fit through the AR6 points (see the diamond points in the previous figure).</p>"},{"location":"components/mitigation/#mimosa.components.mitigation._get_mac_constraints--regional-mac-curve","title":"Regional MAC curve","text":"<p>The regional MAC curve is obtained by scaling the global MAC curve by a regional scaling factor, and links the regional carbon price to the regional relative mitigation \\(a_{t,r}\\):</p> \\[ \\begin{align} \\text{carbon price}_{t,r} &amp;= \\text{regional scaling factor}_{r} \\cdot \\text{MAC}_t(a_{t,r})\\\\ &amp;= \\text{regional scaling factor}_{r} \\cdot \\left( \\gamma \\cdot a_{t,r}^{\\beta}\\right) \\cdot \\text{learning factor}_t. \\end{align} \\] <p>The initial carbon price at time \\(t=0\\) is set to zero:</p> \\[ \\text{carbon price}_{0,r} = 0. \\] Source code in <code>mimosa/components/mitigation.py</code> <pre><code>def MAC(a, m, t, r):\n    factor = m.learning_factor[t] * m.MAC_scaling_factor[r]\n    return factor * m.MAC_gamma * a**m.MAC_beta\n</code></pre> <p>The regional scaling factor transforms the global MAC into a regional MAC:</p> <p>The values of this regional scaling factor are calibrated using SSP2 MAC curves from the TIMER model (the energy submodule of IMAGE). By comparing the carbon price per region required to reach 75% CO<sub>2</sub> reduction in 2050 compared to baseline, relative to the world average, we obtain a scaling factor for the MAC.</p>"},{"location":"components/mitigation/#mimosa.components.mitigation._get_mac_constraints--mitigation-costs","title":"Mitigation costs","text":"<p>[todo]</p>"},{"location":"components/mitigation/#mimosa.components.mitigation._get_mac_constraints--parameters-defined-in-this-module","title":"Parameters defined in this module","text":"<ul> <li><code>MAC_gamma</code>: Calibration level of the MAC (carbon price for 100% reduction). Type: quantity. Default: 2601 USD2005/tCO2. Unit: currency_unit/emissionsrate_unit.</li> <li><code>MAC_beta</code>: Power factor of the MAC curve. Type: float. Default: 3. Min: 0.01. Max: 10.</li> <li><code>MAC_scaling_factor</code></li> <li><code>rel_mitigation_costs_min_level</code>: Minimum level of mitigation costs (rel to GDP). By default, this is 0: no negative abatement costs are allowed. For certain burden sharing regimes, this value can become negative to allow certain (small) financial transfers.. Type: float. Default: 0. Min: -2. Max: 0.</li> </ul> Source code in <code>mimosa/components/mitigation.py</code> <pre><code>def _get_mac_constraints(m: AbstractModel) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n    In MIMOSA, the baseline emissions can be reduced by implementing a carbon price. This increases the price of\n    carbon-intensive technologies relative to cleaner alternatives, which in turn leads to a reduction in emissions.\n\n    ## Marginal Abatement Cost curve\n\n    The carbon price required to reach a certain level of emission reduction is quantified by a Marginal Abatement\n    Cost curve (MAC curve) and gives instantaneous reductions (emission reductions in a given year) relative to the\n    baseline emissions. First, a global MAC curve is defined, which is then scaled for every region to give the regional\n    MAC curve.\n\n    ### Global MAC curve\n\n    The global MAC curve is defined as function of the relative mitigation $a$ (percentage reduction of emissions compared\n    to baseline emissions) and a time-dependent learning factor:\n\n    $$\n    \\\\text{MAC}_t(a) = \\\\left( \\\\gamma \\\\cdot a^{\\\\beta}\\\\right) \\\\cdot \\\\text{learning factor}_t.\n    $$\n\n    The parameters $\\\\gamma$ ([`MAC_gamma`](../parameters.md#economics.MAC.gamma)) and $\\\\beta$ ([`MAC_beta`](../parameters.md#economics.MAC.beta))\n    are calibrated using the IPCC AR6 WG3 report. The learning factor depends on learning by doing and learning over time\n    (see the tab \"Technological learning\").\n\n    ??? info \"Calibrating the MAC using the IPCC AR6 WG3 report\"\n\n        ### Step 1: calibration data source: IPCC AR6\n\n        Specifically, Figure 3.34c from the WGIII full report has been used to calibrate the MAC,\n        as it gives discounted consumption losses from mitigation as function of cumulative CO2 emissions.\n        However, for this use, the figure has been slightly recreated as function of cumulative CO2 emsisions\n        from 2020 to 2100, instead of cumulative CO2 emissions from 2020 to the year of net-zero, to give a more\n        accurate representation of mitigation costs for scenarios that reach net zero. The resulting mitigation costs\n        are:\n\n\n        All costs are calculated as the NPV of GDP losses (as compared to the corresponding baseline GDP path for each\n        scenario) with a fixed social discount rate of 3%/year, as used in the original IPCC AR6 figure.\n\n        ### Step 2: fitting a function to the data\n\n        The next step is to fit a function through the cloud of points. We assume that the MAC is a power function\n        (of a certain power $\\\\beta$). This means that the abatement costs, being the integral of the MAC\n        (area under the MAC) follows a function of power $\\\\beta+1$. We obtain the best fit (highest r-squared)\n        with a power of $\\\\beta=3$, so a cubic MAC. We then perform an Ordinary Least Square regression of the function\n        $a \\\\cdot x^4$ (a power function of $\\\\beta+1=4$) and obtain the best fit shown as solid black line in figure 1:\n\n        ![Mitigation costs as GDP loss in the AR6 database](../assets/fig/calibration_ar6_mitig_costs.jpg)\n\n        Source of underlying GDP losses: [IPCC AR6 WG3 Figure 3.34](https://www.ipcc.ch/report/ar6/wg3/chapter/chapter-3/#figure-3-34)\n\n        ### Step 3: calibrating MIMOSA to the fitted function\n\n        The final step is to calibrate the MAC used in MIMOSA to the OLS fit. In MIMOSA, this means calibrating the\n        parameter $\\\\gamma$. When using\n\n        $$\\\\gamma = 2601 \\\\text{ \\\\$/tCO}_2,$$\n\n        the MIMOSA costs align best with the OLS fit through the AR6 points (see the diamond points in the previous figure).\n\n\n    ### Regional MAC curve\n\n    The regional MAC curve is obtained by scaling the global MAC curve by a regional scaling factor, and links the\n    regional carbon price to the regional relative mitigation $a_{t,r}$:\n\n    $$\n    \\\\begin{align}\n    \\\\text{carbon price}_{t,r} &amp;= \\\\text{regional scaling factor}_{r} \\\\cdot \\\\text{MAC}_t(a_{t,r})\\\\\\\\\n    &amp;= \\\\text{regional scaling factor}_{r} \\\\cdot \\\\left( \\\\gamma \\\\cdot a_{t,r}^{\\\\beta}\\\\right) \\\\cdot \\\\text{learning factor}_t.\n    \\\\end{align}\n    $$\n\n    The initial carbon price at time $t=0$ is set to zero:\n\n    $$\n    \\\\text{carbon price}_{0,r} = 0.\n    $$\n\n    :::mimosa.components.mitigation.MAC\n    The regional scaling factor transforms the global MAC into a regional MAC:\n\n\n    ``` plotly\n    {\"file_path\": \"./assets/plots/MAC_kappa_rel_abatement_0.75_2050.json\"}\n    ```\n\n    The values of this regional scaling factor are calibrated using SSP2 MAC curves from the TIMER model (the energy\n    submodule of IMAGE). By comparing the carbon price per region required to reach 75% CO&lt;sub&gt;2&lt;/sub&gt; reduction in 2050 compared to baseline,\n    relative to the world average, we obtain a scaling factor for the MAC.\n\n\n\n    ## Mitigation costs\n    [todo]\n\n\n    ## Parameters defined in this module\n    - <code>MAC_gamma</code>: Calibration level of the MAC (carbon price for 100% reduction). Type: quantity. Default: 2601 USD2005/tCO2. Unit: currency_unit/emissionsrate_unit.\n    - <code>MAC_beta</code>: Power factor of the MAC curve. Type: float. Default: 3. Min: 0.01. Max: 10.\n    - <code>MAC_scaling_factor</code>\n    - <code>rel_mitigation_costs_min_level</code>: Minimum level of mitigation costs (rel to GDP). By default, this is 0: no negative abatement costs are allowed. For certain burden sharing regimes, this value can become negative to allow certain (small) financial transfers.. Type: float. Default: 0. Min: -2. Max: 0.\n\n    \"\"\"\n\n    constraints = []\n\n    # Mitigation costs and MAC\n    m.mitigation_costs = Var(\n        m.t,\n        m.regions,\n        # within=NonNegativeReals,\n        initialize=0,\n        units=quant.unit(\"currency_unit\"),\n    )\n    m.rel_mitigation_costs = Var(m.t, m.regions, units=quant.unit(\"fraction_of_GDP\"))\n    m.MAC_gamma = Param(doc=\"::economics.MAC.gamma\")\n    m.MAC_beta = Param(doc=\"::economics.MAC.beta\")\n    m.MAC_scaling_factor = Param(\n        m.regions,\n        doc=lambda params: f'regional::MAC.{params[\"economics\"][\"MAC\"][\"regional calibration factor\"]}',\n    )  # Regional scaling of the MAC\n    m.carbonprice = Var(\n        m.t,\n        m.regions,\n        bounds=lambda m: (0, 2 * m.MAC_gamma),\n        units=quant.unit(\"currency_unit/emissions_unit\"),\n    )\n    m.rel_mitigation_costs_min_level = Param(\n        doc=\"::economics.MAC.rel_mitigation_costs_min_level\"\n    )\n    constraints.extend(\n        [\n            RegionalConstraint(\n                lambda m, t, r: m.carbonprice[t, r]\n                == MAC(m.relative_abatement[t, r], m, t, r),\n                \"carbonprice\",\n            ),\n            RegionalInitConstraint(\n                lambda m, r: m.carbonprice[0, r] == 0, \"init_carbon_price\"\n            ),\n            RegionalConstraint(\n                lambda m, t, r: m.rel_mitigation_costs[t, r]\n                == m.mitigation_costs[t, r] / m.GDP_gross[t, r],\n                \"rel_mitigation_costs\",\n                doc=\"$$ \\\\text{rel_mitigation_costs}_{t,r} = \\\\frac{\\\\text{mitigation_costs}_{t,r}}{\\\\text{GDP_gross}_{t,r}} $$\",\n            ),\n            RegionalConstraint(\n                lambda m, t, r: m.rel_mitigation_costs[t, r]\n                &gt;= (m.rel_mitigation_costs_min_level if t &gt; 0 else 0.0),\n                \"rel_mitigation_costs_non_negative\",\n            ),\n        ]\n    )\n\n    # Keep track of relative global costs\n    m.global_rel_mitigation_costs = Var(m.t)\n    constraints.extend(\n        [\n            GlobalConstraint(\n                lambda m, t: m.global_rel_mitigation_costs[t]\n                == sum(m.mitigation_costs[t, r] for r in m.regions)\n                / sum(m.GDP_gross[t, r] for r in m.regions),\n                \"global_rel_mitigation_costs\",\n            )\n        ]\n    )\n\n    # Calculate average global emission reduction per cost unit\n    # and average cost per unit emission reduction\n\n    m.global_emission_reduction_per_cost_unit = Var(\n        m.t, units=quant.unit(\"emissionsrate_unit / currency_unit\")\n    )\n    m.global_cost_per_emission_reduction_unit = Var(\n        m.t, units=quant.unit(\"currency_unit / emissionsrate_unit\")\n    )\n    constraints.extend(\n        [\n            GlobalConstraint(\n                lambda m, t: (\n                    m.global_emission_reduction_per_cost_unit[t]\n                    == sum(m.regional_emission_reduction[t, r] for r in m.regions)\n                    / soft_min(sum(m.mitigation_costs[t, r] for r in m.regions))\n                    if t &gt; 0\n                    else Constraint.Skip\n                ),\n                \"global_emission_reduction_per_cost_unit\",\n            ),\n            GlobalConstraint(\n                lambda m, t: (\n                    m.global_cost_per_emission_reduction_unit[t]\n                    == sum(m.mitigation_costs[t, r] for r in m.regions)\n                    / soft_min(\n                        sum(m.regional_emission_reduction[t, r] for r in m.regions)\n                    )\n                    if t &gt; 0\n                    else Constraint.Skip\n                ),\n                \"global_cost_per_emission_reduction_unit\",\n            ),\n        ]\n    )\n\n    return constraints\n</code></pre>"},{"location":"components/mitigation/#mimosa.components.mitigation._get_learning_constraints--learning-by-doing","title":"Learning by doing","text":"<p>Learning by doing (endogenous technological learning) is a process where the cost of a technology decreases as more of it is produced. Here, the more mitigation has been done in the previous time steps, the cheaper the marginal abatement costs (MAC) become.</p> <p>The learning by doing factor is defined as:</p> \\[ \\text{LBD factor}_t = \\left( \\xi \\cdot \\text{cumulative mitigation}_t + 1 \\right)^{\\log_2(\\rho)}, \\] <p>with \\(\\rho\\) (<code>LBD_rate</code>) the progress ratio (i.e., the reduction in costs for doubling cumulative mitigation capacity) representing empirical studies of endogenous technological learning (see https://www.frontiersin.org/articles/10.3389/fclim.2021.785577/full).</p> <p>\\(\\xi\\) (<code>LBD_scaling</code>) is a scaling factor to transform the units of cumulative mitigation in relative terms (compared to baseline emissions in \\(t=0\\)).</p> <p>The cumulative mitigation is equal to:</p> \\[ \\text{cumulative mitigation}_t = \\text{baseline cum. emissions}_t - \\text{cum. emissions}_t. \\]"},{"location":"components/mitigation/#mimosa.components.mitigation._get_learning_constraints--learning-over-time","title":"Learning over time","text":"<p>Learning over time (exogenous technological learning) is a process where the cost of technology descreases over time, even if no mitigation has been done yet. The learning over time factor is defined as:</p> \\[ \\text{LOT factor}_t = \\frac{1}{(1 + \\lambda)^t}, \\] <p>with \\(\\lambda\\) (<code>LOT_rate</code>) the learning rate. By default, the learning over time rate is zero, so no learning over time is assumed.</p>"},{"location":"components/mitigation/#mimosa.components.mitigation._get_learning_constraints--parameters-defined-in-this-module","title":"Parameters defined in this module","text":"<ul> <li><code>LBD_rate</code>: Learning by doing rate: reduction in marginal mitigation costs for doubling cumulative mitigation capacity. Empirical studies show values between 0.65 (high learning) and 0.95 (low learning). Type: float. Default: 0.82. Min: 0.1. Max: 1.</li> <li><code>LBD_scaling</code>: Scaling factor for learning by doing to transform the units of cumulative mitigation in relative terms (compared to baseline emissions in t=0). Only used for calibration, and should not be used to change the amount of LBD (for this, use the economics &gt; MAC &gt; rho parameter). Type: quantity. Default: 40 GtCO2. Unit: emissions_unit.</li> <li><code>LOT_rate</code>: Learning rate of exogenous learning (learning over time). By default, there is no exogenous learning assumed, as all the technological learning happens endogenously (learning by doing).. Type: float. Default: 0. Min: 0. Max: inf.</li> </ul> Source code in <code>mimosa/components/mitigation.py</code> <pre><code>def _get_learning_constraints(m: AbstractModel) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n\n    In MIMOSA, there are two ways in which the price of mitigation policy can be reduced over time:\n    through learning by doing and learning over time. The learning factor is the product of these two factors.\n\n    ## Learning by doing\n\n    Learning by doing (endogenous technological learning) is a process where the cost of a technology decreases as more of it is produced. Here,\n    the more mitigation has been done in the previous time steps, the cheaper the marginal abatement costs (MAC) become.\n\n    The learning by doing factor is defined as:\n\n    $$\n    \\\\text{LBD factor}_t = \\\\left( \\\\xi \\\\cdot \\\\text{cumulative mitigation}_t + 1 \\\\right)^{\\\\log_2(\\\\rho)},\n    $$\n\n    with $\\\\rho$ ([`LBD_rate`](../parameters.md#economics.MAC.LBD_rate)) the progress ratio (i.e., the reduction in\n    costs for doubling cumulative mitigation capacity) representing empirical studies of endogenous technological\n    learning (see &lt;https://www.frontiersin.org/articles/10.3389/fclim.2021.785577/full&gt;).\n\n    $\\\\xi$ ([`LBD_scaling`](../parameters.md#economics.MAC.LBD_scaling)) is a scaling factor\n    to transform the units of cumulative mitigation in relative terms (compared to baseline emissions in $t=0$).\n\n    The cumulative mitigation is equal to:\n\n    $$\n    \\\\text{cumulative mitigation}_t = \\\\text{baseline cum. emissions}_t - \\\\text{cum. emissions}_t.\n    $$\n\n\n    ## Learning over time\n\n    Learning over time (exogenous technological learning) is a process where the cost of technology descreases over time,\n    even if no mitigation has been done yet. The learning over time factor is defined as:\n\n    $$\n    \\\\text{LOT factor}_t = \\\\frac{1}{(1 + \\\\lambda)^t},\n    $$\n\n    with $\\\\lambda$ ([`LOT_rate`](../parameters.md#economics.MAC.LOT_rate)) the learning rate. By default, the learning over time\n    rate is zero, so no learning over time is assumed.\n\n    ## Parameters defined in this module\n    - <code>LBD_rate</code>: Learning by doing rate: reduction in marginal mitigation costs for doubling cumulative mitigation capacity. Empirical studies show values between 0.65 (high learning) and 0.95 (low learning). Type: float. Default: 0.82. Min: 0.1. Max: 1.\n    - <code>LBD_scaling</code>: Scaling factor for learning by doing to transform the units of cumulative mitigation in relative terms (compared to baseline emissions in t=0). Only used for calibration, and should not be used to change the amount of LBD (for this, use the economics &gt; MAC &gt; rho parameter). Type: quantity. Default: 40 GtCO2. Unit: emissions_unit.\n    - <code>LOT_rate</code>: Learning rate of exogenous learning (learning over time). By default, there is no exogenous learning assumed, as all the technological learning happens endogenously (learning by doing).. Type: float. Default: 0. Min: 0. Max: inf.\n\n    \"\"\"\n    constraints = []\n\n    ### Technological learning\n\n    # Learning by doing\n    m.LBD_rate = Param(doc=\"::economics.MAC.LBD_rate\")\n    m.log_LBD_rate = Param(initialize=log(m.LBD_rate) / log(2))\n    m.LBD_scaling = Param(doc=\"::economics.MAC.LBD_scaling\")\n    m.LBD_factor = Var(m.t)  # , bounds=(0,1), initialize=1)\n    constraints.append(\n        GlobalConstraint(\n            lambda m, t: m.LBD_factor[t]\n            == soft_min(\n                (m.cumulative_global_baseline_emissions[t] - m.cumulative_emissions[t])\n                / m.LBD_scaling\n                + 1.0\n            )\n            ** m.log_LBD_rate,\n            name=\"LBD\",\n        )\n    )\n\n    # Learning over time and total learning factor\n    m.LOT_rate = Param(doc=\"::economics.MAC.LOT_rate\")\n    m.LOT_factor = Var(m.t)\n    m.learning_factor = Var(m.t)\n    constraints.extend(\n        [\n            GlobalConstraint(\n                lambda m, t: m.LOT_factor[t] == 1 / (1 + m.LOT_rate) ** t, \"LOT\"\n            ),\n            GlobalConstraint(\n                lambda m, t: m.learning_factor[t]\n                == (m.LBD_factor[t] * m.LOT_factor[t]),\n                \"learning\",\n            ),\n        ]\n    )\n\n    return constraints\n</code></pre>"},{"location":"components/regions/","title":"Region definitions","text":"<p>MIMOSA uses 26 regions, equal to the IMAGE regions. More info on the IMAGE website.</p> <p>Hover the map to see the region name:</p>"},{"location":"components/sealevelrise/","title":"Sea-level rise","text":"<p> Back to general structure</p> <p>The sea-level rise (SLR) module is based on the AD-RICE 2012 model (Kelly de Bruin, 2014), which in itself is based on RICE 2010. It consists of sea-level rise contributions from thermal expansion, glaciers and small ice caps (GSIC), and the Greenland ice sheet (GIS). Sea-level rise from Antarctica is not included due to the high uncertainty involved.</p>"},{"location":"components/sealevelrise/#mimosa.components.sealevelrise.get_constraints--thermal-expansion","title":"Thermal expansion","text":"<p>The sea-level rise due to thermal expansion is calculated as follows:</p> \\[ \\text{SLR}_{\\text{thermal}, t} = \\text{SLR}_{\\text{thermal},t-1} \\cdot (1 - a)^{\\frac{\\Delta t}{10}} + \\text{temperature}_{t-1} \\cdot a \\cdot \\tfrac{\\Delta t}{10} \\cdot \\text{equil. rate}_{\\text{thermal}} \\] <p>The initial sea-level rise due to thermal expansion (at time \\(t=0\\)) is calculated as:</p> \\[ \\text{SLR}_{\\text{thermal},0} = \\text{SLR}_{\\text{thermal,init}} + a \\cdot (\\text{temperature}_{t=0} \\cdot \\text{equil. rate}_{\\text{thermal}} - \\text{SLR}_{\\text{thermal,init}}) \\] <p>with the following parameters:</p> Name Description Value \\(a\\) Adjustment rate for thermal expansion 0.024076 \\(\\text{equil. rate}_{\\text{thermal}}\\) Equilibrium rate for thermal expansion 0.5 m / \u00b0C \\(\\text{SLR}_{\\text{thermal,init}}\\) Initial sea-level rise due to thermal expansion 0.092067 m"},{"location":"components/sealevelrise/#mimosa.components.sealevelrise.get_constraints--glaciers-and-small-ice-caps-gsic","title":"Glaciers and small ice caps (GSIC)","text":"<p>Next, melting of glaciers and small ice caps (GSIC) contribute to sea-level rise according to:</p> \\[ \\begin{align*} \\text{SLR}_{\\text{GSIC}, t} &amp;= \\text{ SLR}_{\\text{GSIC}, t-1}\\\\ +\\ &amp;\\text{melt rate}\\cdot \\Delta t  \\cdot \\frac{\\text{total ice}_{\\text{GSIC}} - \\text{SLR}_{\\text{GSIC}, t-1}}{\\text{total ice}_{\\text{GSIC}}} \\cdot (\\text{temperature}_{t-1} - \\text{equil. temp}_{\\text{GSIC}}) \\end{align*} \\] <p>with as initial value:</p> \\[ \\text{SLR}_{\\text{GSIC},0} = 0.015 \\] <p>and with the following parameters:</p> Name Description Value \\(\\text{melt rate}\\) Melt rate 0.0008 m / year \\(\\text{total ice}_{\\text{GSIC}}\\) Total ice 0.26 m \\(\\text{equil. temp}_{\\text{GSIC}}\\) Equilibrium temperature -1 \u00b0C"},{"location":"components/sealevelrise/#mimosa.components.sealevelrise.get_constraints--greenland-ice-sheet-gis","title":"Greenland ice sheet (GIS)","text":"<p>The Greenland ice sheet (GIS) contributes to sea-level rise according to:</p> \\[ \\begin{align*} \\text{SLR}_{\\text{GIS}, t} &amp;= \\text{SLR}_{\\text{GIS}, t-1}\\\\ +\\ &amp;\\tfrac{\\Delta t}{10} \\cdot \\tfrac{1}{100} \\cdot (\\text{melt rate above thresh} \\cdot \\text{temperature}_{t-1} + \\text{init melt rate}) \\\\ &amp; \\cdot \\left(1 - \\frac{\\text{SLR}_{\\text{GIS}, t-1}}{\\text{init ice volume}}\\right) \\end{align*} \\] <p>with as initial value:</p> \\[ \\text{SLR}_{\\text{GIS},0} = 0.006 \\] <p>and with the following parameters:</p> Name Description Value \\(\\text{melt rate above thresh}\\) Melt rate above threshold 1.1186 m / year \\(\\text{init melt rate}\\) Initial melt rate 0.6 m / year \\(\\text{init ice volume}\\) Initial ice volume 7.3 m"},{"location":"components/sealevelrise/#mimosa.components.sealevelrise.get_constraints--total-sea-level-rise","title":"Total sea-level rise","text":"<p>The total sea-level rise is the sum of the contributions from thermal expansion, GSIC, and GIS:</p> \\[ \\text{SLR}_t = \\text{SLR}_{\\text{thermal},t} + \\text{SLR}_{\\text{GSIC},t} + \\text{SLR}_{\\text{GIS},t} \\] Source code in <code>mimosa/components/sealevelrise.py</code> <pre><code>def get_constraints(m: AbstractModel) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n    The sea-level rise (SLR) module is based on the AD-RICE 2012 model ([Kelly de Bruin, 2014](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2600006)),\n    which in itself is based on RICE 2010. It consists of sea-level rise contributions from thermal expansion, glaciers and small ice caps (GSIC),\n    and the Greenland ice sheet (GIS). Sea-level rise from Antarctica is not included due to the high uncertainty involved.\n\n    # Thermal expansion\n\n    :::mimosa.components.sealevelrise.slr_thermal_expansion\n        options:\n            show_source: false\n\n    The initial sea-level rise due to thermal expansion (at time $t=0$) is calculated as:\n\n    :::mimosa.components.sealevelrise.slr_thermal_expansion_init\n        options:\n            show_source: false\n\n\n    with the following parameters:\n\n    | Name | Description | Value |\n    | --- | --- | --- |\n    | $a$ | Adjustment rate for thermal expansion | 0.024076 |\n    | $\\\\text{equil. rate}_{\\\\text{thermal}}$ | Equilibrium rate for thermal expansion | 0.5 m / \u00b0C  |\n    | $\\\\text{SLR}_{\\\\text{thermal,init}}$ | Initial sea-level rise due to thermal expansion | 0.092067 m |\n\n\n\n    # Glaciers and small ice caps (GSIC)\n\n    :::mimosa.components.sealevelrise.slr_gsic\n        options:\n            show_source: false\n\n    with as initial value:\n\n    $$\n    \\\\text{SLR}_{\\\\text{GSIC},0} = 0.015\n    $$\n\n    and with the following parameters:\n\n    | Name | Description | Value |\n    | --- | --- | --- |\n    | $\\\\text{melt rate}$ | Melt rate | 0.0008 m / year |\n    | $\\\\text{total ice}_{\\\\text{GSIC}}$ | Total ice | 0.26 m |\n    | $\\\\text{equil. temp}_{\\\\text{GSIC}}$ | Equilibrium temperature | -1 \u00b0C |\n\n\n    # Greenland ice sheet (GIS)\n\n    :::mimosa.components.sealevelrise.slr_gis\n        options:\n            show_source: false\n\n    with as initial value:\n\n    $$\n    \\\\text{SLR}_{\\\\text{GIS},0} = 0.006\n    $$\n\n    and with the following parameters:\n\n    | Name | Description | Value |\n    | --- | --- | --- |\n    | $\\\\text{melt rate above thresh}$ | Melt rate above threshold | 1.1186 m / year |\n    | $\\\\text{init melt rate}$ | Initial melt rate | 0.6 m / year |\n    | $\\\\text{init ice volume}$ | Initial ice volume | 7.3 m |\n\n    # Total sea-level rise\n\n    The total sea-level rise is the sum of the contributions from thermal expansion, GSIC, and GIS:\n\n    $$\n    \\\\text{SLR}_t = \\\\text{SLR}_{\\\\text{thermal},t} + \\\\text{SLR}_{\\\\text{GSIC},t} + \\\\text{SLR}_{\\\\text{GIS},t}\n    $$\n\n\n    \"\"\"\n\n    # Parameters and variables necessary for sea level rise\n    m.slr_thermal = Var(m.t, within=NonNegativeReals, units=quant.unit(\"m\"))\n    m.slr_thermal_equil = Param(initialize=0.5)  # Equilibrium\n    m.slr_thermal_init = Param(\n        initialize=0.0920666936642\n    )  # Initial SLR due to thermal expansion\n    m.slr_thermal_adjust_rate = Param(initialize=0.024076141150722)  # Adjustment rate\n\n    m.slr_cumgsic = Var(m.t, within=NonNegativeReals, units=quant.unit(\"m\"))\n    m.slr_gsic_melt_rate = Param(initialize=0.0008)  # Melt rate\n    m.slr_gsic_total_ice = Param(initialize=0.26)  # Total ice\n    m.slr_gsic_equil_temp = Param(initialize=-1)  # Equilibrium temperature\n\n    m.slr_cumgis = Var(m.t, within=NonNegativeReals, units=quant.unit(\"m\"))\n    m.slr_gis_melt_rate_above_thresh = Param(\n        initialize=1.11860082\n    )  # Melt rate above threshold\n    m.slr_gis_init_melt_rate = Param(initialize=0.6)  # Initial melt rate\n    m.slr_gis_init_ice_vol = Param(initialize=7.3)  # Initial ice volume\n\n    m.total_SLR = Var(m.t, within=NonNegativeReals, units=quant.unit(\"m\"))\n\n    # Constraints relating to SLR\n    constraints = [\n        # Thermal expansion\n        GlobalConstraint(\n            lambda m, t: (\n                m.slr_thermal[t]\n                == slr_thermal_expansion(m.slr_thermal[t - 1], m.temperature[t - 1], m)\n                if t &gt; 0\n                else Constraint.Skip\n            ),\n            name=\"SLR_thermal\",\n        ),\n        GlobalInitConstraint(\n            lambda m: m.slr_thermal[0] == slr_thermal_expansion_init(m)\n        ),\n        # GSIC\n        GlobalConstraint(\n            lambda m, t: (\n                m.slr_cumgsic[t]\n                == slr_gsic(m.slr_cumgsic[t - 1], m.temperature[t - 1], m)\n                if t &gt; 0\n                else Constraint.Skip\n            ),\n            name=\"SLR_GSIC\",\n        ),\n        GlobalInitConstraint(lambda m: m.slr_cumgsic[0] == 0.015),\n        # GIS\n        GlobalConstraint(\n            lambda m, t: (\n                m.slr_cumgis[t] == slr_gis(m.slr_cumgis[t - 1], m.temperature[t - 1], m)\n                if t &gt; 0\n                else Constraint.Skip\n            ),\n            name=\"SLR_GIS\",\n        ),\n        GlobalInitConstraint(lambda m: m.slr_cumgis[0] == 0.006),\n        # Total SLR is sum of each contributing factors\n        GlobalConstraint(\n            lambda m, t: m.total_SLR[t]\n            == m.slr_thermal[t] + m.slr_cumgsic[t] + m.slr_cumgis[t],\n            name=\"total_SLR\",\n        ),\n    ]\n\n    return constraints\n</code></pre>"},{"location":"components/welfare/","title":"Welfare","text":"<p> Back to general structure</p>"},{"location":"components/welfare/#welfare-and-utility","title":"Welfare and utility","text":"<p>The optimisation goal of MIMOSA is to maximise discounted welfare or utility<sup>1</sup>. There are three ways to calculate welfare in MIMOSA: welfare-loss-minimising, cost-minimising, and a general inequality aversion setting which is the generalised version of the first two methods.</p> <p>The welfare module can be chosen using the parameter <code>params[\"model\"][\"welfare module\"]</code>.</p> Welfare-loss-minimising <code>default</code>Cost-minimisingGeneral inequality aversion <p>Usage: <pre><code>params = load_params()\nparams[\"model\"][\"welfare module\"] = \"welfare_loss_minimising\"\nmodel = MIMOSA(params)\n</code></pre></p> Welfare-loss-minimising setting <p>In welfare-loss-minimising setting, the utility is first calculated regionally from the per capita consumption. These regional utilities are then summed up to get the global welfare. This means that costs are weighted differently in different regions, depending on the regional per capita consumption. As a consequence, this setting leads to differentiated carbon prices across regions: poorer regions typically will have lower carbon prices than richer regions.</p> Difference with cost-minimising setting <p>In the cost-minimising setting, the regional per capita consumption values are first added up to a global per capita consumption. The utility function is only then applied to this global per capita consumption to obtain global welfare.</p> Equations <p>First, calculate the regional utility using the regional consumption \\(C_{t,r}\\) and population \\(L_{t,r}\\): $$ U_{t,r} = \\text{utility}(C_{t,r}, L_{t,r}) $$</p> <p>Second, the global welfare is calculated as the sum of the regional utility values weighted by population: $$ W_t = \\sum_r L_{t,r} \\cdot U_{t,r} $$</p> Utility function <p>The utility function is a concave function of per-capita consumption, given by:</p> \\[ \\text{utility}(C, L) = \\left( \\left(\\frac{C}{L}\\right)^{1 - \\text{elasmu}} - 1 \\right) \\cdot \\frac{1}{1 - \\text{elasmu}}\\] <p>where \\(C\\) is the consumption and \\(L\\) the population of a region. \\(\\text{elasmu}\\) is the elasticity of marginal utility. A value of \\(\\text{elasmu}\\) close to 1 approaches a logarithmic utility function: </p> Source code in <code>mimosa/components/welfare/utility_fct.py</code> <pre><code>def calc_utility(consumption, population, elasmu):\n    \"\"\"\n    The utility function is a concave function of per-capita consumption, given by:\n\n    $$ \\\\text{utility}(C, L) = \\\\left( \\\\left(\\\\frac{C}{L}\\\\right)^{1 - \\\\text{elasmu}} - 1 \\\\right) \\\\cdot \\\\frac{1}{1 - \\\\text{elasmu}}$$\n\n    where $C$ is the consumption and $L$ the population of a region. $\\\\text{elasmu}$ is the elasticity of marginal utility. A value of $\\\\text{elasmu}$ close to 1 approaches a logarithmic utility function:\n    ``` plotly\n    {\"file_path\": \"./assets/plots/utility_fct.json\"}\n    ```\n\n    \"\"\"\n\n    # Note that the `soft_min` function is used to avoid division by zero\n    return (soft_min(consumption / population) ** (1 - elasmu) - 1) / (1 - elasmu)\n</code></pre> Parameters defined in this module <ul> <li><code>elasmu</code>: Elasticity of marginal utility. Type: float. Default: 1.001. Min: 0.1. Max: 10.</li> </ul> Source code in <code>mimosa/components/welfare/welfare_loss_minimising.py</code> <pre><code>def get_constraints(m: AbstractModel) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n\n    &lt;h3&gt;Welfare-loss-minimising setting&lt;/h3&gt;\n\n    In welfare-loss-minimising setting, the utility is first calculated regionally\n    from the per capita consumption. These regional utilities are then summed up to\n    get the global welfare. This means that costs are weighted differently in different\n    regions, depending on the regional per capita consumption. As a consequence, this\n    setting leads to differentiated carbon prices across regions: poorer regions typically\n    will have lower carbon prices than richer regions.\n\n    ???+ info \"Difference with cost-minimising setting\"\n        In the cost-minimising setting, the regional per capita consumption values\n        are first added up to a global per capita consumption. The utility function\n        is only then applied to this global per capita consumption to obtain global welfare.\n\n    &lt;h3&gt;Equations&lt;/h3&gt;\n\n    First, calculate the regional utility using the regional consumption $C_{t,r}$ and population $L_{t,r}$:\n    $$ U_{t,r} = \\\\text{utility}(C_{t,r}, L_{t,r}) $$\n\n    Second, the global welfare is calculated as the sum of the regional utility values weighted by population:\n    $$ W_t = \\\\sum_r L_{t,r} \\\\cdot U_{t,r} $$\n\n    &lt;h3&gt;Utility function&lt;/h3&gt;\n    :::mimosa.components.welfare.utility_fct.calc_utility\n\n\n    &lt;h3&gt;Parameters defined in this module&lt;/h3&gt;\n    - <code>elasmu</code>: Elasticity of marginal utility. Type: float. Default: 1.001. Min: 0.1. Max: 10.\n\n    \"\"\"\n    constraints = []\n\n    # Parameters\n    m.elasmu = Param(doc=\"::economics.elasmu\")\n\n    m.utility = Var(m.t, m.regions, initialize=0.1)\n    m.yearly_welfare = Var(m.t)\n\n    constraints.extend(\n        [\n            RegionalConstraint(\n                lambda m, t, r: m.utility[t, r]\n                == calc_utility(m.consumption[t, r], m.population[t, r], m.elasmu),\n                \"utility\",\n            ),\n            GlobalConstraint(\n                lambda m, t: m.yearly_welfare[t]\n                == sum(m.population[t, r] * m.utility[t, r] for r in m.regions),\n                \"yearly_welfare\",\n            ),\n        ]\n    )\n\n    return constraints\n</code></pre> <p>Usage: <pre><code>params = load_params()\nparams[\"model\"][\"welfare module\"] = \"cost_minimising\"\nmodel = MIMOSA(params)\n</code></pre></p> Cost-minimising setting <p>In cost-minimising setting, the global per-capita consumption is first calculated before applying the utility function. This means that costs are weighted equally across regions, regardless of the regional per capita consumption. As a consequence, this setting leads to uniform carbon prices across regions. This is quantitatively similar to using Negishi weights.</p> Difference with welfare-loss-minimising setting <p>In the welfare-loss-minimising setting, the utility function is applied to the regional per capita consumption values, and the regional utilities are then summed up to get the global welfare. This means that costs (from mitigation or damages) have a larger weight in the final welfare in poorer regions than in richer regions.</p> Equations <p>First, calculate the global consumption \\(C_{t,r}\\) and population \\(L_{t,r}\\):</p> \\[ \\widehat{C}_{t} = \\sum_r C_{t,r}, \\] \\[ \\widehat{L}_{t} = \\sum_r L_{t,r}. \\] <p>These are used to calculate the global utility:</p> \\[ W_t = \\widehat{L}_t \\cdot \\text{utility}\\left( \\widehat{C}_{t}, \\widehat{L}_{t} \\right) \\] Utility function <p>The utility function is a concave function of per-capita consumption, given by:</p> \\[ \\text{utility}(C, L) = \\left( \\left(\\frac{C}{L}\\right)^{1 - \\text{elasmu}} - 1 \\right) \\cdot \\frac{1}{1 - \\text{elasmu}}\\] <p>where \\(C\\) is the consumption and \\(L\\) the population of a region. \\(\\text{elasmu}\\) is the elasticity of marginal utility. A value of \\(\\text{elasmu}\\) close to 1 approaches a logarithmic utility function: </p> Source code in <code>mimosa/components/welfare/utility_fct.py</code> <pre><code>def calc_utility(consumption, population, elasmu):\n    \"\"\"\n    The utility function is a concave function of per-capita consumption, given by:\n\n    $$ \\\\text{utility}(C, L) = \\\\left( \\\\left(\\\\frac{C}{L}\\\\right)^{1 - \\\\text{elasmu}} - 1 \\\\right) \\\\cdot \\\\frac{1}{1 - \\\\text{elasmu}}$$\n\n    where $C$ is the consumption and $L$ the population of a region. $\\\\text{elasmu}$ is the elasticity of marginal utility. A value of $\\\\text{elasmu}$ close to 1 approaches a logarithmic utility function:\n    ``` plotly\n    {\"file_path\": \"./assets/plots/utility_fct.json\"}\n    ```\n\n    \"\"\"\n\n    # Note that the `soft_min` function is used to avoid division by zero\n    return (soft_min(consumption / population) ** (1 - elasmu) - 1) / (1 - elasmu)\n</code></pre> Parameters defined in this module <ul> <li><code>elasmu</code>: Elasticity of marginal utility. Type: float. Default: 1.001. Min: 0.1. Max: 10.</li> </ul> Source code in <code>mimosa/components/welfare/cost_minimising.py</code> <pre><code>def get_constraints(m: AbstractModel) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n\n    &lt;h3&gt;Cost-minimising setting&lt;/h3&gt;\n\n    In cost-minimising setting, the global per-capita consumption is first calculated before\n    applying the utility function. This means that costs are weighted equally across regions,\n    regardless of the regional per capita consumption. As a consequence, this setting leads to\n    uniform carbon prices across regions. This is quantitatively similar to using Negishi weights.\n\n    ???+ info \"Difference with welfare-loss-minimising setting\"\n        In the welfare-loss-minimising setting, the utility function is applied to the regional\n        per capita consumption values, and the regional utilities are then summed up to get the\n        global welfare. This means that costs (from mitigation or damages) have a larger weight in\n        the final welfare in poorer regions than in richer regions.\n\n\n    &lt;h3&gt;Equations&lt;/h3&gt;\n\n    First, calculate the global consumption $C_{t,r}$ and population $L_{t,r}$:\n\n    $$ \\\\widehat{C}_{t} = \\\\sum_r C_{t,r}, $$\n\n    $$ \\\\widehat{L}_{t} = \\\\sum_r L_{t,r}. $$\n\n    These are used to calculate the global utility:\n\n    $$ W_t = \\\\widehat{L}_t \\\\cdot \\\\text{utility}\\\\left( \\\\widehat{C}_{t}, \\\\widehat{L}_{t} \\\\right) $$\n\n    &lt;h3&gt;Utility function&lt;/h3&gt;\n    :::mimosa.components.welfare.utility_fct.calc_utility\n\n\n    &lt;h3&gt;Parameters defined in this module&lt;/h3&gt;\n    - <code>elasmu</code>: Elasticity of marginal utility. Type: float. Default: 1.001. Min: 0.1. Max: 10.\n\n    \"\"\"\n    constraints = []\n\n    # Parameters\n    m.elasmu = Param(doc=\"::economics.elasmu\")\n\n    m.utility = Var(m.t, m.regions, initialize=10)\n    m.yearly_welfare = Var(m.t)\n\n    constraints.extend(\n        [\n            RegionalConstraint(\n                lambda m, t, r: m.utility[t, r]\n                == m.consumption[t, r] / m.population[t, r],\n                \"utility\",\n            ),\n            GlobalConstraint(\n                lambda m, t: m.yearly_welfare[t]\n                == sum(m.population[t, r] for r in m.regions)\n                * calc_utility(\n                    sum(m.consumption[t, r] for r in m.regions),\n                    sum(m.population[t, r] for r in m.regions),\n                    m.elasmu,\n                ),\n                \"yearly_welfare\",\n            ),\n        ]\n    )\n\n    return constraints\n</code></pre> <p>Usage: <pre><code>params = load_params()\nparams[\"model\"][\"welfare module\"] = \"inequal_aversion_general\"\nmodel = MIMOSA(params)\n</code></pre></p> General inequality aversion <p>TODO</p> Parameters defined in this module <ul> <li><code>elasmu</code>: Elasticity of marginal utility. Type: float. Default: 1.001. Min: 0.1. Max: 10.</li> <li>param::inequal_aversion</li> </ul> Source code in <code>mimosa/components/welfare/inequal_aversion_general.py</code> <pre><code>def get_constraints(m: AbstractModel) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n    &lt;h3&gt;General inequality aversion&lt;/h3&gt;\n\n    TODO\n\n    &lt;h3&gt;Parameters defined in this module&lt;/h3&gt;\n    - <code>elasmu</code>: Elasticity of marginal utility. Type: float. Default: 1.001. Min: 0.1. Max: 10.\n    - param::inequal_aversion\n\n    \"\"\"\n    constraints = []\n\n    # Parameters\n    m.elasmu = Param(doc=\"::economics.elasmu\")\n    m.inequal_aversion = Param(doc=\"::economics.inequal_aversion\")\n\n    m.utility = Var(m.t, m.regions, initialize=10)\n    m.yearly_welfare = Var(m.t)\n\n    constraints.extend(\n        [\n            RegionalConstraint(\n                lambda m, t, r: m.utility[t, r]\n                == calc_regional_utility(\n                    m.consumption[t, r], m.population[t, r], m.inequal_aversion\n                ),\n                \"utility\",\n            ),\n            GlobalConstraint(\n                lambda m, t: m.yearly_welfare[t]\n                == sum(m.population[t, r] for r in m.regions)\n                * calc_global_utility(\n                    sum(m.utility[t, r] for r in m.regions),\n                    sum(m.population[t, r] for r in m.regions),\n                    m.elasmu,\n                    m.inequal_aversion,\n                ),\n                \"yearly_welfare\",\n            ),\n        ]\n    )\n\n    return constraints\n</code></pre>"},{"location":"components/welfare/#optimisation-goal-and-discounting","title":"Optimisation goal and discounting","text":"<p>TODO</p> <ol> <li> <p>While the terms welfare and utility can be used interchangeably, we typically refer to utility as the regional utility, and welfare as the global population-weighted utility.\u00a0\u21a9</p> </li> </ol>"},{"location":"extending/","title":"Extending MIMOSA","text":""},{"location":"extending/#forking-mimosa-from-github","title":"Forking MIMOSA from GitHub","text":""},{"location":"extending/#general-form-of-the-model","title":"General form of the model","text":"<p>MIMOSA is built as a Pyomo model: an open-source Python package optimisation modelling language.  Pyomo models consist of a combination of variables, constraints and parameters. The constraints link together the variables in the form of (non-linear) equations. One variable is defined as the optimisation objective: in MIMOSA's case,  the net present value of the global welfare. Pyomo translates the combination of variables, constraints and parameters to a form suitable for an external solver. The solver maximises the objective variable, while trying to fulfill all the  constraints.</p> <p>On this page, we give examples of how to extend MIMOSA by adding new variables and constraints, by adding new parameters, and by creating completely new model components (modules). The basis of MIMOSA is a Pyomo <code>AbstractModel</code>: a model object where all variables and other components will be added to and which will be sent to the solver. In <code>mimosa/abstract_model.py</code>, this object is created:</p> <pre><code>m = AbstractModel()\n</code></pre> <p>This model will always be referred to as <code>m</code>.</p> <p>A note about file structure</p> <p>After forking and cloning MIMOSA to your computer, you will find a file structure that looks like this:</p> MIMOSA file structure<pre><code>mimosa\n\u2502   abstract_model.py # (1)!\n\u2502   mimosa.py\n\u2502\n\u2514\u2500\u2500\u2500 components # (2)!\n    \u2502   emissions.py\n    \u2502   mitigation.py\n    \u2502   ...\n\u2502\n\u2514\u2500\u2500\u2500 inputdata\n    \u2502\n    \u2514\u2500\u2500\u2500 config / config_default.yaml # (3)!\n    \u2502\n    \u2514\u2500\u2500\u2500 regionalparams / ...\n    \u2502\n    \u2514\u2500\u2500\u2500 data / ...\n\nrun.py # (4)!\n</code></pre> <ol> <li>All the model components are tied together in this file</li> <li>The different components discussed in the Model documentation pages are defined in the     Python files in this folder</li> <li>All parameters types and default values are defined in this file</li> <li>Example of a basic model run. Place your run files here, such that the mimosa package from this folder is used,     and not a version previously installed through <code>pip install mimosa</code>.</li> </ol> <p>The different components discussed in the Model documentation pages are defined in the Python files in the folder <code>mimosa/components</code>. All these modules are tied together in the file <code>mimosa/abstract_model.py</code>.</p> <p>Typically, when extending MIMOSA, the following steps can be followed:</p> <ol> <li>Create a new component (<code>optional</code>, only necessary if the extension is a new module)</li> <li>Add new variables and constraints to the model</li> <li>Add new parameters and data to the model</li> </ol>"},{"location":"extending/components/","title":"New components","text":"<p>When the extension to MIMOSA is significant, it is recommended to create a new component. This component will contain all the new variables, constraints, and parameters that are part of the module.</p>"},{"location":"extending/components/#create-the-new-component","title":"Create the new component","text":"<p>As an example, we will create a new component called \"New component\". To do this, create a new file in the <code>mimosa/components</code> folder called <code>new_component.py</code>:</p> MIMOSA file structure: create a new file<pre><code>mimosa\n\u2502   abstract_model.py\n\u2502   mimosa.py\n\u2502\n\u2514\u2500\u2500\u2500 components\n    \u2502   emissions.py\n    \u2502   mitigation.py\n    \u2502   new_component.py\n    \u2502   ...\n\u2502\n\u2514\u2500\u2500\u2500 inputdata\n    \u2502   ...\n</code></pre> <p>A component always consists of a function <code>get_constraints(m)</code>, in which all the new variables, parameters, and constraints are defined. The function needs to return a list of all the newly created constraints:</p> mimosa/components/new_component.py<pre><code>from mimosa.common import (\n    AbstractModel, Param, Var,\n    GlobalConstraint, GlobalInitConstraint,\n    RegionalConstraint, RegionalInitConstraint,\n    quant\n)\n\ndef get_constraints(m: AbstractModel):\n    \"\"\"\n    Documentation of what the new component does\n    \"\"\"\n\n    # New variables\n    m.new_var = Var()\n\n    # New parameters\n    m.new_param = Param()\n\n    # Create a list of all the new constraints\n    constraints = [\n        GlobalConstraint(...),\n        ...\n    ]\n\n    # Return the list of constraints\n    return constraints\n</code></pre>"},{"location":"extending/components/#link-the-new-component-to-the-model","title":"Link the new component to the model","text":"<p>To link the new component to the model, import the new component in <code>mimosa/abstract_model.py</code>:</p> mimosa/abstract_model.py<pre><code>from mimosa.components import new_component\n\ndef create_model():\n    m = AbstractModel()\n\n    # ... existing code ...\n\n    ######################\n    # Components\n    ######################\n\n    # Add the new component\n    constraints.extend(new_component.get_constraints(m))\n\n    # ... existing code ...\n\n    return m\n</code></pre>"},{"location":"extending/parameters/","title":"Parameters","text":"<p>Parameteres are values used in MIMOSA that can be changed without changing the code. A new parameter called <code>new_param</code> can be added in the <code>get_constraints</code> function of any component:</p> <pre><code>def get_constraints(m):\n    # ... existing code ...\n\n    m.new_param = Param()\n\n    # ... existing code ...\n</code></pre> <p>This creates an abstract parameter (without a value). It still needs a value. This can be done for scalars (non-regional parameters) using the default configuration file and for regional parameters using CSV input values.</p>"},{"location":"extending/parameters/#config-params","title":"Parameters from config file: non-regional parameters","text":"<p>All parameters that are not regional have an entry in the <code>config_default.yaml</code> file (located in the folder <code>mimosa/inputdata/config/</code>). This defines the type of the parameter (numerical, boolean, string, etc.), the default value, and the range of possible values. For example, the following entry defines the parameter <code>economics - PRTP</code>:</p> mimosa/inputdata/config/config_default.yaml<pre><code>...\neconomics:\n  PRTP:\n    descr: Pure rate of time preference\n    type: float\n    min: 0\n    max: 0.2\n    default: 0.015\n...\n</code></pre> <p>Each parameter entry in the configuration file contains the following fields:</p> <ul> <li><code>descr</code>: A description of the parameter</li> <li><code>type</code>: The type of the parameter (e.g. <code>float</code>, <code>int</code>, <code>str</code>, <code>bool</code>, ...)</li> <li><code>default</code>: The default value of the parameter</li> <li>Optionally some extra fields depending on the type of parameter</li> </ul> <p>The next step is to link this configuration entry to the <code>Param</code> in MIMOSA. This is done using the <code>doc</code> field when defining the <code>Param</code>:</p> <pre><code>m.PRTP = Param(doc=\"::economics.PRTP\")\n</code></pre> <p>Note that the <code>config_default.yaml</code> file is structured as a nested dictionary. In this case, the PRTP parameter is located within the <code>economics</code> group. This structure can be arbitrary and doesn't need to match the name of the component. It is purely used to structure the configuration file.</p> <p>When running MIMOSA, the command <code>params = load_params()</code> loads all the default values from the configuration file as a nested dictionary. These values can be changed by modifying the <code>params</code> dictionary:</p> <pre><code>from mimosa import MIMOSA, load_params\n\nparams = load_params() \nparams[\"economics\"][\"PRTP\"] = 0.001\n...\n</code></pre> <p>After this step, MIMOSA always double checks the dictionary <code>params</code> to check if all the parameter values have the correct type and match specifications of the configuration entry (for example, if the value is within the specified range). If not, MIMOSA will raise an error.</p>"},{"location":"extending/parameters/#types-of-parameter-values","title":"Types of parameter values","text":"<p>In the example above, the PRTP has a type <code>float</code>. The following types are supported (especially note that for numerical values with units (values that are not dimensionless), the type <code>quantity</code> should be used):</p> Parser types float <p>Numerical value (float)</p> <p>Extra properties:</p> <ul> <li><code>min</code>: lower bound of parameter (default: -inf)</li> <li><code>max</code>: upper bound of parameter (default: +inf)</li> </ul> <p>Example usage:</p> <p><pre><code>time:\n  dt:\n    default: 5\n    descr: Timestep in years\n    max: 20\n    min: 0.5\n    type: float\n</code></pre> </p> int <p>Numerical value (integer)</p> <p>Extra properties:</p> <ul> <li><code>min</code>: lower bound of parameter (default: -inf)</li> <li><code>max</code>: upper bound of parameter (default: +inf)</li> </ul> <p>Example usage:</p> <p><pre><code>time:\n  start:\n    default: 2020\n    descr: Year in which the model starts\n    max: 2100\n    min: 1900\n    type: int\n</code></pre> </p> bool <p>Boolean value (true or false).</p> <p>Example usage:</p> <p><pre><code>economics:\n  damages:\n    ignore damages:\n      default: false\n      descr: Flag to not take into account the damages in the GDP (but damages are calculated)\n      type: bool\n</code></pre> </p> str <p>String value</p> enum <p>Enum (discrete list of options)</p> <p>Extra properties:</p> <ul> <li><code>values</code>: list of allowed values</li> </ul> <p>Example usage:</p> <p><pre><code>SSP:\n  default: SSP2\n  descr: SSP, used for population, baseline GDP and baseline emissions\n  type: enum\n  values:\n  - SSP1\n  - SSP2\n  - SSP3\n  - SSP4\n  - SSP5\n</code></pre> </p> quantity <p>Quantity (value with unit). The provided value will be converted to the <code>unit</code>, if possible.</p> <p>For example, if the <code>unit</code> of a parameter is GtCO2, and the parameter value provided by the user is \"1000 MtCO2\", the value will be converted automatically to \"1 GtCO2\". The value passed to MIMOSA will therefore be 1, and not 1000. If the user provides \"1000 US$\", MIMOSA will raise an exception, as this cannot be converted to GtCO2.</p> <p>Extra properties:</p> <ul> <li><code>unit</code>: Unit of the quantity</li> </ul> <p>Example usage:</p> <p><pre><code>economics:\n  MAC:\n    gamma:\n      default: 2601 USD2005/tCO2\n      descr: Calibration level of the MAC (carbon price for 100% reduction)\n      type: quantity\n      unit: currency_unit/emissionsrate_unit\n</code></pre> </p> list <p>List of values. The values are also parsed individually, depending on the parser type given in the property <code>values</code>.</p> <p>Extra properties:</p> <ul> <li><code>values</code>: parser information for the values. For example, the values can be int, float, values with units, etc.</li> </ul> <p>Example usage:</p> <p><pre><code>regionsmappings:\n  default:\n  - conversiontable: inputdata/regions/IMAGE26_COACCH.csv\n    regionstype1: IMAGE26\n    regionstype2: COACCH\n  - conversiontable: inputdata/regions/IMAGE26_ADRICE2010.csv\n    regionstype1: IMAGE26\n    regionstype2: ADRICE2010\n  - conversiontable: inputdata/regions/IMAGE26_ADRICE2012.csv\n    regionstype1: IMAGE26\n    regionstype2: ADRICE2012\n  descr: List of region types and their conversion tables. Only used for regional parameters,\n    not for aggregating or disaggregating variables or other output.\n  type: list\n  values:\n    descr: Dictionary with keys `regionstype1`, `regionstype2` and `conversiontable`.\n    type: dict\n</code></pre> </p> dict <p>Dictionary with keys and values. The values are also parsed individually, depending on the parser type given in the property <code>values</code>.</p> <p>Extra properties:</p> <ul> <li><code>values</code>: parser information for the values. For example, the values can be int, float, values with units, etc.</li> <li><code>keys</code>: parser information for the keys</li> </ul> <p>Example usage:</p> <p><pre><code>regional_parameter_files:\n  default:\n    COACCH:\n      filename: inputdata/regionalparams/COACCH.csv\n      regionstype: COACCH\n    MAC:\n      filename: inputdata/regionalparams/mac.csv\n      regionstype: IMAGE26\n    economics:\n      filename: inputdata/regionalparams/economics.csv\n      regionstype: IMAGE26\n  descr: Dictionary of regional parameter files. If the regionstype of the file is different\n    from the regionstype of the model, the file is converted using the `regionsmappings`\n    parameter.\n  keys:\n    descr: Names of the parameter category (e.g. 'MAC', 'damage', 'adaptation', etc.)\n      used when assigning the values to the regional parameters.\n    type: str\n  type: dict\n  values:\n    descr: Dictionary with keys `filename` and `regionstype`\n    type: dict\n</code></pre> </p> datasource <p>Data source for a variable. It's a dictionary with the keys <code>variable</code>, <code>unit</code>, <code>scenario</code>, <code>model</code>, and <code>file</code>.</p> <p>Example usage:</p> <p><pre><code>input:\n  variables:\n    GDP:\n      default:\n        file: inputdata/data/data_IMAGE_SSP.csv\n        model: IMAGE\n        scenario: '{SSP}-Ref-SPA0-V17'\n        unit: currency_unit\n        variable: GDP|PPP\n      descr: Data source of GDP\n      type: datasource\n</code></pre> </p> filepath <p>Filepath value. Currently exactly the same as the string type.</p> str_or_plain_dict <p>Either a string or a dictionary. The keys/values of the dictionary are not checked or parsed separately.</p>"},{"location":"extending/parameters/#regional-params","title":"Regional parameters","text":"<p>The configuration file can be used to set scalar parameters. However, some parameters are regional. These are created like:</p> <pre><code>m.new_regional_param = Param(m.regions)\n</code></pre> <p>Initializing their value is done in three steps:</p> <ol> <li> <p>Create a CSV file with a column <code>region</code> and the columns with regional parameter values you want to use:</p> <p>In the folder <code>mimosa/inputdata/regionalparams/</code>, create a new CSV file:</p> <pre><code>mimosa\n\u2502   ...\n\u2502\n\u2514\u2500\u2500\u2500 inputdata\n    \u2514\u2500\u2500\u2500 config\n        \u2502   config_default.csv\n    \u2514\u2500\u2500\u2500 regionalparams\n        \u2502   economics.csv\n        |   mac.csv \n        |   newfile.csv\n        |   ...\n</code></pre> <p>This file should have at least a column <code>region</code> and one (or more) columns for the regional values:</p> <p> <code>mimosa/inputdata/regionalparams/newfile.csv</code></p> region newparam1 newparam2 ... CAN 1.992 2.317 ... USA 2.035 1.745 ... ... ... <p>Note that this file can contain multiple columns (for multiple regional parameters). It is good practice to group the parameter values when the parameters are somehow related with each other.</p> </li> <li> <p>Register this regional parameter file in the configuration file under the key <code>regional_parameter_files</code>:</p> mimosa/inputdata/config/config_default.yaml<pre><code>...\nregional_parameter_files:\n  ...\n  default:\n    economics:\n      filename: inputdata/regionalparams/economics.csv\n      regionstype: IMAGE26\n    newparamgroup:\n      filename: inputdata/regionalparams/newfile.csv\n      regionstype: IMAGE26\n    ...\n</code></pre> What if my parameter values have a different regional resolution? <p>Todo</p> </li> <li> <p>Link the <code>Param</code> to the relevant column in the CSV file:</p> <pre><code>m.new_regional_param = Param(m.regions, doc=\"regional::newparamgroup.newparam1\")\n</code></pre> </li> </ol>"},{"location":"extending/parameters/#time-and-region-dependent-data","title":"Time and region dependent data","text":"<p>The third type of parameters are time and region dependent parameters. This is typically used for baseline data, such as population, GDP, etc. </p> <p>They are defined like any other parameter, but with the <code>time</code> and <code>regions</code> dimensions. For example, the population data is defined as:</p> <pre><code>m.population = Param(\n    m.t,\n    m.regions,\n    doc=\"timeandregional::population\",\n    units=quant.unit(\"billion people\"), # (1)!\n)\n</code></pre> <ol> <li>The <code>units</code> field is optional, but it is good practice to include it. This is especially important for numerical values with units (values that are not dimensionless). The <code>quant</code> module is imported as <code>quant</code> from the <code>mimosa</code> package.</li> </ol> <p>Just like regional parameters, the parameter values are linked to the underlying data using the <code>doc</code> field, starting with <code>timeandregional::</code>. The input data source should be in IAMC format. For each parameter, the filename, variable, scenario and model should be specified in the configuration file:</p> mimosa/inputdata/config/config_default.yaml<pre><code>...\ninput:\n  variables:\n    population: # (1)!\n      descr: Data source of population\n      type: datasource\n      default:\n        variable: Population\n        unit: population_unit\n        scenario: \"{SSP}-Ref-SPA0-V17\"\n        model: IMAGE\n        file: inputdata/data/data_IMAGE_SSP.csv\n    ...\n</code></pre> <ol> <li>The name defined here (<code>population</code>) should match the name used in the <code>doc</code> field of the parameter definition: <code>timeandregional::population</code>.</li> </ol> <p>The <code>file</code> field should point to the IAMC formatted data file. The IAMC format is a CSV file with the following columns:</p> <p> <code>mimosa/inputdata/data/data_IMAGE_SSP.csv</code></p> Model Scenario Region Variable Unit 2010 2020 2030 2040 2050 2060 2070 2080 2090 2100 IMAGE SSP1-Ref-SPA0-V17 BRA GDP|PPP billion US$2005/yr 1967.58 2679.72 3829.08 5331.48 6912.49 8386.99 9572.49 10475.8 11043.6 11245.4 IMAGE SSP2-Ref-SPA0-V17 BRA GDP|PPP billion US$2005/yr 1967.58 2697.05 3618.3 4491.94 5378.44 6285.55 7175.7 8083.65 8970.67 9881.11 IMAGE SSP3-Ref-SPA0-V17 BRA GDP|PPP billion US$2005/yr 1967.58 2714.89 3464.9 3888.87 4152.04 4333.24 4462.94 4575.67 4633.92 4679.27 ... ... ... ... Configuration values dependent on other parameter values <p>In the example above, the name of the scenario depends on the SSP. Every string in the configuration file can contain references to other parameters, and are referred to using curly brackets <code>{}</code>. If you want to refer to a nested parameter (like <code>effort sharing &gt; regime</code>), they should be joined with <code>-</code>:</p> <pre><code>scenario: \"Scenario-with-{SSP}-and-{effort sharing - regime}\"\n</code></pre>"},{"location":"extending/parameters/#advanced-dynamic-parameter-settings","title":"Advanced: dynamic parameter settings","text":""},{"location":"extending/parameters/#advanced-complex-parameter-manipulations-with-instantiate_paramspy","title":"Advanced: complex parameter manipulations with <code>instantiate_params.py</code>","text":""},{"location":"extending/variables_constraints/","title":"Variables and constraints","text":""},{"location":"extending/variables_constraints/#variables","title":"Variables","text":"<p>Let's create a new variable that calculates the regional carbon intensity (emissions divided by GDP). You can add this variable to any of the components in the folder <code>mimosa/components</code>, but the most logical place is probably the file <code>mimosa/components/cobbdouglas.py</code>, which contains all GDP-related variables and constraints. Each component has a function <code>get_constraints(...)</code>, which is called from the main <code>abstract_model.py</code> file.</p> <p>Inside the function <code>get_constraints()</code>, create the new variable <code>m.carbon_intensity</code>:</p> mimosa/components/cobbdouglas.py<pre><code>def get_constraints(m):\n    # ... existing code ...\n\n    # New variable\n    m.carbon_intensity = Var(m.t, m.regions)\n\n    # ... existing code ...\n</code></pre> <p>If the variable is not dependent on either time or region, remove the <code>m.t</code> or <code>m.regions</code> from the variable definition.</p>"},{"location":"extending/variables_constraints/#constraints","title":"Constraints","text":"<p>The relationships between variables are defined through constraints. Constraints are Python functions (often lambda functions) that represent the underlying equations of the model. In our example, a constraint would relate the carbon intensity to the emissions and the GDP:</p> <pre><code>RegionalConstraint(\n    lambda m, t, r: m.carbon_intensity[t, r] == m.regional_emissions[t, r] / m.GDP_net[t, r],\n    name=\"carbon_intensity\"\n)\n</code></pre> <p>The constraint consists of two parts: the lambda function with the equation, and the name of the constraint. Note that the lambda function always has the model <code>m</code> as the first argument, followed by the indices of the variables that the constraint relates.</p> <p>There are four types of constraints, depending on whether they depend on regions, time, or both:</p> <ul> <li> <p>Region and time dependent:</p> <p><code>RegionalConstraint(lambda m, t, r: ..., name=\"...\")</code></p> </li> <li> <p>Only region dependent:</p> <p><code>RegionalInitConstraint(lambda m, r: ..., name=\"...\")</code></p> </li> <li> <p>Only time dependent, not on region:</p> <p><code>GlobalConstraint(lambda m, t: ..., name=\"...\")</code></p> </li> <li> <p>Not dependent on time nor on region:</p> <p><code>GlobalInitConstraint(lambda m: ..., name=\"...\")</code></p> </li> </ul> <p>Next, MIMOSA needs to know where the constraints are created. Every component therefore consists of a function called <code>get_constraints()</code> (see Components). This function returns a list of constraints. Add the new constraint to the list:</p> <pre><code>def get_constraints(m):\n    constraints = []\n    # ... existing code ...\n\n    constraints.extend([\n        RegionalConstraint(\n            lambda m, t, r: m.carbon_intensity[t, r] == m.regional_emissions[t, r] / m.GDP_net[t, r],\n            name=\"carbon_intensity\"\n        ),\n        ...\n    ])\n\n    return constraints\n</code></pre> <p>Note: as shown in this example, constraints do not need to be equality constraints. They can also be inequality constraints. Also,  constraints do need to be in the form of <code>m.variable == expression</code>: the left-hand-side and the right-hand-side can be non-linear combinations of variables and parameters.</p>"},{"location":"extending/variables_constraints/#conditionally-skip-constraints","title":"Conditionally skip constraints","text":"<p>If a constraint should only be enforced under certain conditions, you can use an the <code>Constraint.Skip</code> statement. This can be for certain time periods, regions, or any condition based on parameters. It is not possible to skip constraints based on variable values.</p> <pre><code>GlobalConstraint(\n    lambda m, t: (\n        m.global_emissions[t] &lt;= 0\n        if m.year(t) &gt; 2100\n        else Constraint.Skip\n    ),\n    name=\"net_zero_after_2100\",\n)\n</code></pre> <p>Note: the variable <code>t</code> is a time index (starting at <code>t=0</code>), and <code>m.year(t)</code> returns the year of the time index <code>t</code>.</p>"},{"location":"extending/variables_constraints/#advanced-soft-equality-constraints","title":"Advanced: soft-equality constraints","text":""},{"location":"extending/variables_constraints/#advanced-numerical-stability","title":"Advanced: numerical stability","text":"<ul> <li>Avoid division by zero: add a small number to the denominator</li> <li>Avoid large numbers: scale the variables by choosing appropriate units</li> <li>Avoid negative numbers in exponents and square roots by using the <code>soft_min</code> and <code>soft_max</code> functions</li> </ul>"}]}