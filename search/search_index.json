{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#mimosa-mathematical-integrated-model-for-optimal-and-stylised-assessment","title":"MIMOSA: Mathematical Integrated Model for Optimal and Stylised Assessment","text":"Warning <p>This documentation is still under construction and will be updated regularly.</p> <p>MIMOSA is a recent simple IAM based on FAIR, with 26 regions covering the whole world. It is a relatively simple Cost-Benefit IAM but still covers the relevant technological and socio-economic dynamics. Temperature is a linear function of cumulative CO2 emissions. MIMOSA uses the DICE sea-level rise module. The mitigation costs, population, initial capital stock and baseline GDP and CO2 emissions are regional. The direct regional mitigation costs are calculated as area under the Marginal Abatement Cost (MAC) curve, and have been calibrated to the IPCC AR6 WGIII database.</p> <p>Documentation  Installation  Running </p>"},{"location":"#general","title":"General","text":"<p>The model is written in the Python optimisation package Pyomo. It is mainly an <code>AbstractModel</code> (object containing all the variables, parameters and constraints, without the actual data values), which is then transformed into a <code>ConcreteModel</code> by putting all the parameter values in it. This <code>ConcreteModel</code> is sent to the solver (IPOPT, an open-source large-scale nonlinear optimisation suite).</p> <p> Schematic overview of the MIMOSA model. From [1].</p>"},{"location":"#how-to-cite","title":"How to cite","text":"<p>When using MIMOSA, please cite [1] (global version) and [2] (regional version).</p>"},{"location":"#references","title":"References","text":"<p>[1]  van der Wijst, KI., Hof, A.F. &amp; van Vuuren, D.P. On the optimality of 2\u00b0C targets and a decomposition of uncertainty. Nature Communications 12, 2575 (2021). https://doi.org/10.1038/s41467-021-22826-5</p> <p>[2]  van der Wijst, KI., Bosello, F., Dasgupta, S. et al. New damage curves and multimodel analysis suggest lower optimal temperature. Nature Climate Change 13, 434\u2013441 (2023). https://doi.org/10.1038/s41558-023-01636-1</p>"},{"location":"extending_mimosa/","title":"Extending MIMOSA","text":"<ul> <li>Adding a variable</li> <li> <p>Adding a parameter</p> </li> <li> <p>Adding a new component (import abstract_model etc)</p> </li> </ul>"},{"location":"installation/","title":"Installing MIMOSA","text":"<p>MIMOSA is written in Python, can be installed using <code>pip</code>: <pre><code>pip install mimosa\n</code></pre></p> <p>If you don't have Python installed yet, we highly recommend to use Anaconda to install python. </p>"},{"location":"installation/#installing-the-optimisation-engine-ipopt","title":"Installing the optimisation engine IPOPT","text":"<p>Since MIMOSA is an optimisation model, an optimisation engine needs to be specified. This can be installed locally (see With IPOPT installed locally), but an easier way is to use a free cloud-based optimisation service called NEOS.</p> Using the NEOS serverWith IPOPT installed locally <p>The MIMOSA runs can easily be sent to the NEOS server (https://neos-server.org) for remote optimisation. First, on their website, sign up for a free account. You can then run MIMOSA with NEOS enabled by simply providing it with the email address you used to sign up for NEOS:</p> <pre><code>from mimosa import MIMOSA, load_params\n\nparams = load_params()\n\nmodel1 = MIMOSA(params)\nmodel1.solve(use_neos=True, neos_email=\"your.email@email.com\")\nmodel1.save(\"run1\")\n</code></pre> <p>Depending on the MIMOSA parameters chosen and on how busy the NEOS server is, running the model might take a while (typically a couple of minutes).</p> <p>A faster way to run MIMOSA, and which doesn't require an internet connection, is to install the open-source optimisation engine IPOPT locally: <pre><code>conda install -c conda-forge ipopt\n</code></pre> However, this sometimes fails on Windows. To fix it, go to https://www.coin-or.org/download/binary/Ipopt/ and download the latest win64-version. Unzip the files. A subfolder <code>bin</code> should contain the file <code>ipopt.exe</code>. The next step is to add this folder to your PATH environment: Windows &gt; Edit the system environment variables &gt; Environment variables... &gt; Select \"Path\" and click Edit... &gt; Click New and browse to the folder you just unzipped. Make sure to select the <code>bin</code> subfolder as this folder contains the file <code>ipopt.exe</code>.</p> More detailed steps on how to install IPOPT on Windows <ol> <li>Once you've downloaded the zip file of the latest win64-version on the coin website (currently <code>Ipopt-3.11.1-win64-intel13.1.zip</code>), unzip this file to folder of your choice. In the unzipped folder, there should be a <code>bin</code> folder.</li> <li>The next step is to tell Windows to look for IPOPT in this <code>bin</code> directory. This is achieved by adding the relevant folder to the environment path of Windows. Click on Start (or press the Win key), type <code>environment</code> and press Enter. This should open the dialog <code>Edit the system environment variables</code>.</li> <li>Click on <code>Environment variables</code>, select <code>Path</code> and click edit.</li> <li>Here, you can add the folder with the IPOPT bin folder. Click on New and add the folder you unzipped IPOPT in, making sure to select the sub-folder <code>bin</code>:</li> <li>You can test if everything works by opening an Anaconda Prompt and typing <code>ipopt</code>. It should show something like this:</li> </ol> <p>Once IPOPT is installed, MIMOSA can be ran without NEOS: <pre><code>from mimosa import MIMOSA, load_params\n\nparams = load_params()\n\nmodel1 = MIMOSA(params)\nmodel1.solve()  # No NEOS required\nmodel1.save(\"run1\")\n</code></pre></p> <p>Next: Running MIMOSA </p>"},{"location":"parameters/","title":"Parameter reference","text":"SSP <p>SSP, used for population, baseline GDP and baseline emissions</p> <ul> <li> <p>Type: enum</p> </li> <li> <p>Default: SSP2</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Allowed values:</p> <ul> <li>SSP1</li> <li>SSP2</li> <li>SSP3</li> <li>SSP4</li> <li>SSP5</li> </ul> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"SSP\"] = \"SSP2\"\nmodel = MIMOSA(params)\n</code></pre> regionstype <p> </p> <p>Name of the region definition. Used in the mapping of the regional parameters.</p> <ul> <li> <p>Type: enum</p> </li> <li> <p>Default: IMAGE26</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Allowed values:</p> <ul> <li>IMAGE26</li> <li>SSP5</li> <li>World</li> </ul> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"regionstype\"] = \"IMAGE26\"\nmodel = MIMOSA(params)\n</code></pre> regions <p> </p> <p>Dictionary of all regions with optional dictionaries defining, optionally, manual values for certain parameters for that specific region.</p> <ul> <li> <p>Type: dict</p> </li> <li> <p>Default: {'CAN': None, 'USA': None, 'MEX': None, 'RCAM': None, 'BRA': None, 'RSAM': None, 'NAF': None, 'WAF': None, 'EAF': None, 'SAF': None, 'WEU': None, 'CEU': None, 'TUR': None, 'UKR': None, 'STAN': None, 'RUS': None, 'ME': None, 'INDIA': None, 'KOR': None, 'CHN': None, 'SEAS': None, 'INDO': None, 'JAP': None, 'OCE': None, 'RSAS': None, 'RSAF': None}</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"regions\"] = {'CAN': None, 'USA': None, 'MEX': None, 'RCAM': None, 'BRA': None, 'RSAM': None, 'NAF': None, 'WAF': None, 'EAF': None, 'SAF': None, 'WEU': None, 'CEU': None, 'TUR': None, 'UKR': None, 'STAN': None, 'RUS': None, 'ME': None, 'INDIA': None, 'KOR': None, 'CHN': None, 'SEAS': None, 'INDO': None, 'JAP': None, 'OCE': None, 'RSAS': None, 'RSAF': None}\nmodel = MIMOSA(params)\n</code></pre> <p></p>"},{"location":"parameters/#time_1","title":"time","text":"start <p>Year in which the model starts</p> <ul> <li> <p>Type: int</p> </li> <li> <p>Default: 2020</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 1900</p> </li> <li> <p>Max: 2100</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"time\"][\"start\"] = 2020\nmodel = MIMOSA(params)\n</code></pre> end <p> </p> <p>Last year of the model run</p> <ul> <li> <p>Type: int</p> </li> <li> <p>Default: 2150</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 1901</p> </li> <li> <p>Max: 2300</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"time\"][\"end\"] = 2150\nmodel = MIMOSA(params)\n</code></pre> dt <p> </p> <p>Timestep in years</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 5</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0.5</p> </li> <li> <p>Max: 20</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"time\"][\"dt\"] = 5\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#economics_1","title":"economics","text":"PRTP <p>Pure rate of time preference</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 0.015</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0</p> </li> <li> <p>Max: 0.2</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"PRTP\"] = 0.015\nmodel = MIMOSA(params)\n</code></pre> elasmu <p> </p> <p>Elasticity of marginal utility</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 1.001</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0.1</p> </li> <li> <p>Max: 10</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"elasmu\"] = 1.001\nmodel = MIMOSA(params)\n</code></pre> inequal_aversion <p> </p> <p>Parameter of inequality aversion. Should be between 0 and <code>elasmu</code>. Only used when welfare_module='inequal_aversion_general'</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 0.5</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0.0</p> </li> <li> <p>Max: 3</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"inequal_aversion\"] = 0.5\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#economics-gdp","title":"economics &gt; GDP","text":"alpha <p>Output elasticity of capital</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 0.3</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0</p> </li> <li> <p>Max: 1</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"GDP\"][\"alpha\"] = 0.3\nmodel = MIMOSA(params)\n</code></pre> depreciation of capital <p> </p> <p>Yearly depreciation rate of capital stock</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 0.05</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0</p> </li> <li> <p>Max: inf</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"GDP\"][\"depreciation of capital\"] = 0.05\nmodel = MIMOSA(params)\n</code></pre> savings rate <p> </p> <p>Fraction of GDP used for investments</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 0.21</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0</p> </li> <li> <p>Max: 1</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"GDP\"][\"savings rate\"] = 0.21\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#economics-mac","title":"economics &gt; MAC","text":"beta <p>Power factor of the MAC curve</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 3</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0.01</p> </li> <li> <p>Max: 10</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"MAC\"][\"beta\"] = 3\nmodel = MIMOSA(params)\n</code></pre> rho <p> </p> <p>Learning by doing rate (needs more explanation)</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 0.82</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0.1</p> </li> <li> <p>Max: 1</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"MAC\"][\"rho\"] = 0.82\nmodel = MIMOSA(params)\n</code></pre> gamma <p> </p> <p>Calibration level of the MAC (carbon price for 100% reduction)</p> <ul> <li> <p>Type: quantity</p> </li> <li> <p>Default: 2601 USD2005/tCO2</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Unit: currency_unit/emissionsrate_unit</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"MAC\"][\"gamma\"] = \"2601 USD2005/tCO2\"\nmodel = MIMOSA(params)\n</code></pre> regional calibration factor <p> </p> <p>Column from mac.csv to be used for the regional MACs. The MACs are calibrated from TIMER SSP2-RCP2.6 MACs at a given year and a given carbon price / abatement level.</p> <ul> <li> <p>Type: enum</p> </li> <li> <p>Default: kappa_rel_abatement_0.75_2050</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Allowed values:</p> <ul> <li>kappa_carbonprice_200_2030</li> <li>kappa_carbonprice_200_2050</li> <li>kappa_carbonprice_200_2070</li> <li>kappa_carbonprice_200_2100</li> <li>kappa_carbonprice_300_2030</li> <li>kappa_carbonprice_300_2050</li> <li>kappa_carbonprice_300_2070</li> <li>kappa_carbonprice_300_2100</li> <li>kappa_carbonprice_500_2030</li> <li>kappa_carbonprice_500_2050</li> <li>kappa_carbonprice_500_2070</li> <li>kappa_carbonprice_500_2100</li> <li>kappa_carbonprice_1000_2030</li> <li>kappa_carbonprice_1000_2050</li> <li>kappa_carbonprice_1000_2070</li> <li>kappa_carbonprice_1000_2100</li> <li>kappa_rel_abatement_0.25_2030</li> <li>kappa_rel_abatement_0.25_2050</li> <li>kappa_rel_abatement_0.25_2070</li> <li>kappa_rel_abatement_0.25_2100</li> <li>kappa_rel_abatement_0.4_2030</li> <li>kappa_rel_abatement_0.4_2050</li> <li>kappa_rel_abatement_0.4_2070</li> <li>kappa_rel_abatement_0.4_2100</li> <li>kappa_rel_abatement_0.5_2050</li> <li>kappa_rel_abatement_0.5_2070</li> <li>kappa_rel_abatement_0.5_2100</li> <li>kappa_rel_abatement_0.75_2050</li> <li>kappa_rel_abatement_0.75_2070</li> <li>kappa_rel_abatement_0.75_2100</li> </ul> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"MAC\"][\"regional calibration factor\"] = \"kappa_rel_abatement_0.75_2050\"\nmodel = MIMOSA(params)\n</code></pre> rel_mitigation_costs_min_level <p> </p> <p>Minimum level of mitigation costs (rel to GDP). By default, this is 0: no negative abatement costs are allowed. For certain burden sharing regimes, this value can become negative to allow certain (small) financial transfers.</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 0</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: -2</p> </li> <li> <p>Max: 0</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"MAC\"][\"rel_mitigation_costs_min_level\"] = 0\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#economics-emission-trade","title":"economics &gt; emission trade","text":"min rel payment level <p>Which percentage of the area under the MAC of a region should it pay itself (minimum)? If false: no limt</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: False</p> </li> <li> <p>Can be false: True</p> </li> <li> <p>Min: 0</p> </li> <li> <p>Max: 1</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"emission trade\"][\"min rel payment level\"] = False\nmodel = MIMOSA(params)\n</code></pre> max rel payment level <p> </p> <p>Which percentage of the area under the MAC of a region should it pay itself (maximum)? If false: no limit</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: False</p> </li> <li> <p>Can be false: True</p> </li> <li> <p>Min: 1</p> </li> <li> <p>Max: inf</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"emission trade\"][\"max rel payment level\"] = False\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#economics-damages","title":"economics &gt; damages","text":"percentage reversible <p>Factor of damages that are reversible</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 1</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0</p> </li> <li> <p>Max: 1</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"damages\"][\"percentage reversible\"] = 1\nmodel = MIMOSA(params)\n</code></pre> scale factor <p> </p> <p>Manual scaling factor to increase or decrease damages</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 1</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: -inf</p> </li> <li> <p>Max: inf</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"damages\"][\"scale factor\"] = 1\nmodel = MIMOSA(params)\n</code></pre> ignore damages <p> </p> <p>Flag to not take into account the damages in the GDP (but damages are calculated)</p> <ul> <li> <p>Type: bool</p> </li> <li> <p>Default: False</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"damages\"][\"ignore damages\"] = False\nmodel = MIMOSA(params)\n</code></pre> quantile <p> </p> <p>Damage quantile (Only used for COACCH)</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 0.5</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0.025</p> </li> <li> <p>Max: 0.975</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"damages\"][\"quantile\"] = 0.5\nmodel = MIMOSA(params)\n</code></pre> coacch_slr_withadapt <p> </p> <p>Flag to use the SLR-with-Adapation damage functions (Only used for COACCH)</p> <ul> <li> <p>Type: bool</p> </li> <li> <p>Default: True</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"damages\"][\"coacch_slr_withadapt\"] = True\nmodel = MIMOSA(params)\n</code></pre> coacch_combined_slr_nonslr_damages <p> </p> <p>If true, do not model SLR damages separately from non-SLR, but use the combined damage functions (Only used for COACCH)</p> <ul> <li> <p>Type: bool</p> </li> <li> <p>Default: False</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"damages\"][\"coacch_combined_slr_nonslr_damages\"] = False\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#economics-adaptation","title":"economics &gt; adaptation","text":"curr_level <p>When adaptation level is fixed, keep it at this level (Only used for AD-RICE2010)</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 0</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Min: 0</p> </li> <li> <p>Max: 1</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"adaptation\"][\"curr_level\"] = 0\nmodel = MIMOSA(params)\n</code></pre> fixed <p> </p> <p>Flag to keep adaptation at fixed value (curr_level). (Only used for AD-RICE2010) If false: the adaptation level is endogenously optimised.</p> <ul> <li> <p>Type: bool</p> </li> <li> <p>Default: False</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"economics\"][\"adaptation\"][\"fixed\"] = False\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#emissions_1","title":"emissions","text":"carbonbudget <p>Value of the carbon budget. Example: \"800 GtCO2\" (the unit is important). If set to False, no carbon budget is imposed: this is cost-benefit mode. Default: False.</p> <ul> <li> <p>Type: quantity</p> </li> <li> <p>Default: False</p> </li> <li> <p>Can be false: True</p> </li> <li> <p>Unit: emissions_unit</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"emissions\"][\"carbonbudget\"] = False\nmodel = MIMOSA(params)\n</code></pre> global min level <p> </p> <p>Limit on the emission level (globally), mostly used for negative emissions. Can also be false, then no limit is imposed</p> <ul> <li> <p>Type: quantity</p> </li> <li> <p>Default: -20 GtCO2/yr</p> </li> <li> <p>Can be false: True</p> </li> <li> <p>Unit: emissionsrate_unit</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"emissions\"][\"global min level\"] = \"-20 GtCO2/yr\"\nmodel = MIMOSA(params)\n</code></pre> regional min level <p> </p> <p>Limit on the emission level (per region), mostly used for negative emissions. Can also be false, then no limit is imposed</p> <ul> <li> <p>Type: quantity</p> </li> <li> <p>Default: -10 GtCO2/yr</p> </li> <li> <p>Can be false: True</p> </li> <li> <p>Unit: emissionsrate_unit</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"emissions\"][\"regional min level\"] = \"-10 GtCO2/yr\"\nmodel = MIMOSA(params)\n</code></pre> not positive after budget year <p> </p> <p>If true, impose net-zero emissions after budget year (2100)</p> <ul> <li> <p>Type: bool</p> </li> <li> <p>Default: True</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"emissions\"][\"not positive after budget year\"] = True\nmodel = MIMOSA(params)\n</code></pre> non increasing emissions after 2100 <p> </p> <p>If true, the regional emissions after 2100 are not allowed to climb.</p> <ul> <li> <p>Type: bool</p> </li> <li> <p>Default: True</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"emissions\"][\"non increasing emissions after 2100\"] = True\nmodel = MIMOSA(params)\n</code></pre> baseline carbon intensity <p> </p> <p>If true, use baseline carbon intensity to calculate baseline emissions. If false, the SSP baseline emissions are used, regardless of lower GDP.</p> <ul> <li> <p>Type: bool</p> </li> <li> <p>Default: True</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"emissions\"][\"baseline carbon intensity\"] = True\nmodel = MIMOSA(params)\n</code></pre> cumulative_emissions_trapz <p> </p> <p>If true, calculate cumulative emissions using trapezoidal interpolation. If false, cum. emissions are simply cum_emissions[t-1] + dt * cum_emissions[t]. This is less accurate, but better for numerical stability. For small dt the  approximation is usually still acceptable.</p> <ul> <li> <p>Type: bool</p> </li> <li> <p>Default: True</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"emissions\"][\"cumulative_emissions_trapz\"] = True\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#emissions-inertia","title":"emissions &gt; inertia","text":"global <p>Maximum reduction speed, in % of initial emissions (should be negative) Can also be false, then no inertia limit is imposed</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: False</p> </li> <li> <p>Can be false: True</p> </li> <li> <p>Min: -inf</p> </li> <li> <p>Max: 0</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"emissions\"][\"inertia\"][\"global\"] = False\nmodel = MIMOSA(params)\n</code></pre> regional <p> </p> <p>Maximum reduction speed, in % of initial emissions (should be negative) Can also be false, then no inertia limit is imposed</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: -0.05</p> </li> <li> <p>Can be false: True</p> </li> <li> <p>Min: -inf</p> </li> <li> <p>Max: 0</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"emissions\"][\"inertia\"][\"regional\"] = -0.05\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#burden-sharing","title":"burden sharing","text":"regime <p>Type of burden sharing to be used</p> <ul> <li> <p>Type: enum</p> </li> <li> <p>Default: noregime</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Allowed values:</p> <ul> <li>noregime</li> <li>equal_mitigation_costs</li> <li>equal_total_costs</li> <li>per_cap_convergence</li> <li>per_cap_convergence_fake</li> </ul> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"burden sharing\"][\"regime\"] = \"noregime\"\nmodel = MIMOSA(params)\n</code></pre> percapconv_year <p> </p> <p>Year of convergence to per capita emission allowance  (only used when burden sharing - regime is per_cap_convergence) Can also be false, then always use grandfathering</p> <ul> <li> <p>Type: float</p> </li> <li> <p>Default: 2050</p> </li> <li> <p>Can be false: True</p> </li> <li> <p>Min: 2020</p> </li> <li> <p>Max: 2200</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"burden sharing\"][\"percapconv_year\"] = 2050\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#temperature_1","title":"temperature","text":"initial <p>Temperature in initial year of model run (2020 by default).</p> <ul> <li> <p>Type: quantity</p> </li> <li> <p>Default: 1.16 delta_degC</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Unit: temperature_unit</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"temperature\"][\"initial\"] = \"1.16 delta_degC\"\nmodel = MIMOSA(params)\n</code></pre> TCRE <p> </p> <p>Transient Climate Response to CO2 Emissions</p> <ul> <li> <p>Type: quantity</p> </li> <li> <p>Default: 0.62 delta_degC/(TtCO2)</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Unit: (temperature_unit)/(emissions_unit)</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"temperature\"][\"TCRE\"] = \"0.62 delta_degC/(TtCO2)\"\nmodel = MIMOSA(params)\n</code></pre> target <p> </p> <p>Temperature target in 2100 (and beyond). Can also be false, then no temperature target is imposed</p> <ul> <li> <p>Type: quantity</p> </li> <li> <p>Default: False</p> </li> <li> <p>Can be false: True</p> </li> <li> <p>Unit: temperature_unit</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"temperature\"][\"target\"] = False\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#model_1","title":"model","text":"damage module <p>Damage module to be used</p> <ul> <li> <p>Type: enum</p> </li> <li> <p>Default: COACCH</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Allowed values:</p> <ul> <li>COACCH</li> <li>RICE2010</li> <li>RICE2012</li> </ul> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"model\"][\"damage module\"] = \"COACCH\"\nmodel = MIMOSA(params)\n</code></pre> emissiontrade module <p> </p> <p>Emission trade module to be used</p> <ul> <li> <p>Type: enum</p> </li> <li> <p>Default: notrade</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Allowed values:</p> <ul> <li>notrade</li> <li>globalcostpool</li> <li>emissiontrade</li> </ul> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"model\"][\"emissiontrade module\"] = \"notrade\"\nmodel = MIMOSA(params)\n</code></pre> financialtransfer module <p> </p> <p>Financial transfer module to be used</p> <ul> <li> <p>Type: enum</p> </li> <li> <p>Default: notransfer</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Allowed values:</p> <ul> <li>notransfer</li> <li>globaldamagepool</li> </ul> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"model\"][\"financialtransfer module\"] = \"notransfer\"\nmodel = MIMOSA(params)\n</code></pre> welfare module <p> </p> <p>Welfare and utility module to be used</p> <ul> <li> <p>Type: enum</p> </li> <li> <p>Default: welfare_loss_minimising</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Allowed values:</p> <ul> <li>welfare_loss_minimising</li> <li>cost_minimising</li> <li>inequal_aversion_general</li> </ul> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"model\"][\"welfare module\"] = \"welfare_loss_minimising\"\nmodel = MIMOSA(params)\n</code></pre> objective module <p> </p> <p>Objective module to be used</p> <ul> <li> <p>Type: enum</p> </li> <li> <p>Default: utility</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Allowed values:</p> <ul> <li>utility</li> <li>globalcosts</li> </ul> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"model\"][\"objective module\"] = \"utility\"\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#input_1","title":"input","text":"db_filename <p>Path to IAMC-formatted CSV file for baseline data</p> <ul> <li> <p>Type: filepath</p> </li> <li> <p>Default: inputdata/data/data_IMAGE_SSP.csv</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"input\"][\"db_filename\"] = \"inputdata/data/data_IMAGE_SSP.csv\"\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#input-baselines","title":"input &gt; baselines","text":""},{"location":"parameters/#input-baselines-ssp1","title":"input &gt; baselines &gt; SSP1","text":"scenario <p>Scenario name of SSP1 baseline</p> <ul> <li> <p>Type: str</p> </li> <li> <p>Default: SSP1-Ref-SPA0-V17</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"input\"][\"baselines\"][\"SSP1\"][\"scenario\"] = \"SSP1-Ref-SPA0-V17\"\nmodel = MIMOSA(params)\n</code></pre> model <p> </p> <p>Model name of SSP1 baseline</p> <ul> <li> <p>Type: str</p> </li> <li> <p>Default: IMAGE</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"input\"][\"baselines\"][\"SSP1\"][\"model\"] = \"IMAGE\"\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#input-baselines-ssp2","title":"input &gt; baselines &gt; SSP2","text":"scenario <p>Scenario name of SSP2 baseline</p> <ul> <li> <p>Type: str</p> </li> <li> <p>Default: SSP2-Ref-SPA0-V17</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"input\"][\"baselines\"][\"SSP2\"][\"scenario\"] = \"SSP2-Ref-SPA0-V17\"\nmodel = MIMOSA(params)\n</code></pre> model <p> </p> <p>Model name of SSP2 baseline</p> <ul> <li> <p>Type: str</p> </li> <li> <p>Default: IMAGE</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"input\"][\"baselines\"][\"SSP2\"][\"model\"] = \"IMAGE\"\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#input-baselines-ssp3","title":"input &gt; baselines &gt; SSP3","text":"scenario <p>Scenario name of SSP3 baseline</p> <ul> <li> <p>Type: str</p> </li> <li> <p>Default: SSP3-Ref-SPA0-V17</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"input\"][\"baselines\"][\"SSP3\"][\"scenario\"] = \"SSP3-Ref-SPA0-V17\"\nmodel = MIMOSA(params)\n</code></pre> model <p> </p> <p>Model name of SSP3 baseline</p> <ul> <li> <p>Type: str</p> </li> <li> <p>Default: IMAGE</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"input\"][\"baselines\"][\"SSP3\"][\"model\"] = \"IMAGE\"\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#input-baselines-ssp4","title":"input &gt; baselines &gt; SSP4","text":"scenario <p>Scenario name of SSP4 baseline</p> <ul> <li> <p>Type: str</p> </li> <li> <p>Default: SSP4-Ref-SPA0-V17</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"input\"][\"baselines\"][\"SSP4\"][\"scenario\"] = \"SSP4-Ref-SPA0-V17\"\nmodel = MIMOSA(params)\n</code></pre> model <p> </p> <p>Model name of SSP4 baseline</p> <ul> <li> <p>Type: str</p> </li> <li> <p>Default: IMAGE</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"input\"][\"baselines\"][\"SSP4\"][\"model\"] = \"IMAGE\"\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#input-baselines-ssp5","title":"input &gt; baselines &gt; SSP5","text":"scenario <p>Scenario name of SSP5 baseline</p> <ul> <li> <p>Type: str</p> </li> <li> <p>Default: SSP5-Ref-SPA0-V17</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"input\"][\"baselines\"][\"SSP5\"][\"scenario\"] = \"SSP5-Ref-SPA0-V17\"\nmodel = MIMOSA(params)\n</code></pre> model <p> </p> <p>Model name of SSP5 baseline</p> <ul> <li> <p>Type: str</p> </li> <li> <p>Default: IMAGE</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"input\"][\"baselines\"][\"SSP5\"][\"model\"] = \"IMAGE\"\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#input-variables","title":"input &gt; variables","text":"GDP <p>Variable name for GDP in data file</p> <ul> <li> <p>Type: enum</p> </li> <li> <p>Default: GDP|PPP</p> </li> <li> <p>Can be false: False</p> </li> <li> <p>Allowed values:</p> <ul> <li>GDP|PPP</li> <li>GDP|MER</li> </ul> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"input\"][\"variables\"][\"GDP\"] = \"GDP|PPP\"\nmodel = MIMOSA(params)\n</code></pre> emissions <p> </p> <p>Variable name for emissions variable</p> <ul> <li> <p>Type: str</p> </li> <li> <p>Default: Emissions|CO2</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"input\"][\"variables\"][\"emissions\"] = \"Emissions|CO2\"\nmodel = MIMOSA(params)\n</code></pre> population <p> </p> <p>Variable name for population variable</p> <ul> <li> <p>Type: str</p> </li> <li> <p>Default: Population</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"input\"][\"variables\"][\"population\"] = \"Population\"\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"parameters/#simulation_1","title":"simulation","text":"simulationmode <p>If true, the model is run in simulation mode: then some variables will be imposed exogenously and fixed. If false, <code>constraint_variables</code> and <code>deactivated_constraints</code> are ignored.</p> <ul> <li> <p>Type: bool</p> </li> <li> <p>Default: False</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"simulation\"][\"simulationmode\"] = False\nmodel = MIMOSA(params)\n</code></pre> constraint_variables <p> </p> <p>Dictionary of variable names with associated path to file containing values for that variable</p> <ul> <li> <p>Type: dict</p> </li> <li> <p>Default: None</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"simulation\"][\"constraint_variables\"] = None\nmodel = MIMOSA(params)\n</code></pre> deactivated_constraints <p> </p> <p>List of constraint names to be disabled</p> <ul> <li> <p>Type: list</p> </li> <li> <p>Default: None</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"simulation\"][\"deactivated_constraints\"] = None\nmodel = MIMOSA(params)\n</code></pre> custom_mapping <p> </p> <p>Custom mapping of parameter values or variables</p> <ul> <li> <p>Type: dict</p> </li> <li> <p>Default: None</p> </li> <li> <p>Can be false: False</p> </li> </ul> <p>Example usage: </p> <pre><code>params = load_params()\nparams[\"simulation\"][\"custom_mapping\"] = None\nmodel = MIMOSA(params)\n</code></pre>"},{"location":"run/","title":"Running MIMOSA","text":""},{"location":"run/#base-run","title":"Base run","text":"<p>A basic run of MIMOSA requires 4 steps: loading the parameters, building the model instance, solving the model and finally saving the output. With this code, the default parameter values are used (see Parameter reference).</p> <pre><code>from mimosa import MIMOSA, load_params\n\nparams = load_params()  # (1)!\n\nmodel1 = MIMOSA(params) # (2)!\nmodel1.solve() # (3)!\n\nmodel1.save(\"run1\") # (4)!\n</code></pre> <ol> <li>Read the default parameters</li> <li>Build the model using the parameters</li> <li>Once the model is built, send the model to the solver.      Note that if you use the NEOS solver, use the syntax <code>model1.solve(use_neos=True, neos_email=\"your.email@email.com\")</code></li> <li>Export the output to the file output/run1.csv</li> </ol>"},{"location":"run/#reading-the-output","title":"Reading the output","text":""},{"location":"run/#changing-parameters","title":"Changing parameters","text":"<p>The default parameters from <code>load_params()</code> are given as a nested dictionary. Every item of this dictionary can be changed. Note that only the values can be changed, it is not possible to add or substract parameters to this dictionary (without Extending MIMOSA).</p>"},{"location":"run/#example-1-carbon-budget","title":"Example 1: carbon budget","text":"<pre><code>from mimosa import MIMOSA, load_params\n\nparams = load_params()\n\nparams[\"emissions\"][\"carbonbudget\"] = \"500 GtCO2\" # (1)!\n\nmodel1 = MIMOSA(params)\nmodel1.solve()\n\nmodel1.save(\"run_example1\")\n</code></pre> <ol> <li>Change the parameter of emissions &gt; carbonbudget to the string \"500 GtCO2\"</li> </ol>"},{"location":"run/#example-2","title":"Example 2:","text":""},{"location":"run/#doing-multiple-runs","title":"Doing multiple runs","text":""},{"location":"components/economics/","title":"Economics","text":"<p> Back to general structure</p>"},{"location":"components/economics/#mimosa.components.cobbdouglas.get_constraints--economic-module-and-production-function","title":"Economic module and production function","text":""},{"location":"components/economics/#mimosa.components.cobbdouglas.get_constraints--gross-and-net-gdp","title":"Gross and net GDP","text":"<p>The core of the model is the economic module, detailing how GDP, investments and consumptions vary over time. We use a traditional Cobb-Douglas production function. This means that the gross GDP is calculated by:</p> <p>$$ \\text{GDP}_{\\text{gross},t,r} = \\text{TFP}_{t,r} \\cdot L^{1-\\alpha}_{t,r} \\cdot K^{\\alpha}_{t,r}, $$ with \\(\\text{TFP}\\) the total factor productivity (exogenously calibrated from the baseline SSP scenarios) \\(L\\) the labor (represented by the total population), \\(K\\) the capital stock and \\(\\alpha\\) the share of capital in the production function.</p> Source code in <code>mimosa/common/economics.py</code> <pre><code>def calc_GDP(TFP, L, K, alpha):\n    \"\"\"\n    $$ \\\\text{GDP}_{\\\\text{gross},t,r} = \\\\text{TFP}\\\\_{t,r} \\\\cdot L^{1-\\\\alpha}\\\\_{t,r} \\\\cdot K^{\\\\alpha}\\\\_{t,r}, $$\n    with $\\\\text{TFP}$ the total factor productivity (exogenously calibrated from the baseline SSP scenarios)\n    $L$ the labor (represented by the total population), $K$ the capital stock and $\\\\alpha$ the share of capital in the production function.\n\n    \"\"\"\n    return TFP * L ** (1 - alpha) * K**alpha\n</code></pre> <p>The net GDP is then calculated by subtracting the damages and mitigation costs from the gross GDP. (Note that in MIMOSA, the damages are expressed as a fraction of the gross GDP, whereas the mitigation costs are expressed in absolute terms.)</p> \\[ \\text{GDP}_{\\text{net},t,r} = \\text{GDP}_{\\text{gross},t,r} \\cdot (1 - \\text{damage costs}_{t,r}) - \\text{mitigation costs}_{t,r}\\]"},{"location":"components/economics/#mimosa.components.cobbdouglas.get_constraints--investments-and-consumption","title":"Investments and consumption","text":"<p>This net GDP is then split in a part of investments (\\(I_t\\)) and a part of consumption (\\(C_t\\)), according to a fixed savings rate (\\(\\text{sr}\\)):</p> \\[ I_{t,r} = \\text{sr} \\cdot \\text{GDP}_{\\text{net},t,r}, \\] \\[ C_{t,r} = (1 - \\text{sr}) \\cdot \\text{GDP}_{\\text{net},t,r}. \\]"},{"location":"components/economics/#mimosa.components.cobbdouglas.get_constraints--capital-stock","title":"Capital stock","text":"<p>The capital stock \\(K_t\\) grows over time according to the investments and the depreciation of the capital stock:</p> \\[ K_{t,r} = K_{t-1,r} + \\Delta t \\cdot \\frac{\\partial K_{t,r}}{\\partial t}, \\] <p>with the change in capital stock calculated by:</p> \\[ \\frac{\\partial K_{t,r}}{\\partial t} = \\frac{1}{\\Delta t} \\cdot ((1 - dk)^{\\Delta t}  - 1) \\cdot K_{t,r} + I_{t,r}.\\] Source code in <code>mimosa/common/economics.py</code> <pre><code>def calc_dKdt(K, dk, I, dt):\n    \"\"\"\n    $$ \\\\frac{\\\\partial K_{t,r}}{\\\\partial t} = \\\\frac{1}{\\\\Delta t} \\\\cdot ((1 - dk)^{\\\\Delta t}  - 1) \\\\cdot K_{t,r} + I_{t,r}.$$\n    \"\"\"\n    return ((1 - dk) ** dt - 1) / dt * K + I\n</code></pre> <p>Since this only gives the change in capital stock, we need to add the initial capital stock to get the actual capital stock. This is calculated as a region-dependent multiple of the initial GDP:</p> \\[ K_{t=0,r} = \\text{init_capitalstock_factor}_r \\cdot \\text{GDP}_{t=0,r}. \\] <p>The initial capital stock factor is a calibration factor to obtain the initial capital stock. TODO: Source (IMF) </p>"},{"location":"components/economics/#mimosa.components.cobbdouglas.get_constraints--parameters-defined-in-this-module","title":"Parameters defined in this module","text":"<ul> <li><code>init_capitalstock_factor</code></li> <li><code>alpha</code>: Output elasticity of capital. Type: float. Default: 0.3. Min: 0. Max: 1.</li> <li><code>dk</code>: Yearly depreciation rate of capital stock. Type: float. Default: 0.05. Min: 0. Max: inf.</li> <li><code>sr</code>: Fraction of GDP used for investments. Type: float. Default: 0.21. Min: 0. Max: 1.</li> <li><code>ignore_damages</code>: Flag to not take into account the damages in the GDP (but damages are calculated). Type: bool. Default: False.</li> </ul> Source code in <code>mimosa/components/cobbdouglas.py</code> <pre><code>def get_constraints(m: AbstractModel) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n    # Economic module and production function\n\n    ## Gross and net GDP\n\n    The core of the model is the economic module, detailing how GDP, investments and\n    consumptions vary over time. We use a traditional Cobb-Douglas production function. This means\n    that the gross GDP is calculated by:\n\n    :::mimosa.common.economics.calc_GDP\n\n    The net GDP is then calculated by subtracting the damages and\n    mitigation costs from the gross GDP. *(Note that in MIMOSA, the damages are expressed as a fraction of the gross GDP,\n    whereas the mitigation costs are expressed in absolute terms.)*\n\n    $$ \\\\text{GDP}_{\\\\text{net},t,r} = \\\\text{GDP}_{\\\\text{gross},t,r} \\\\cdot (1 - \\\\text{damage costs}_{t,r}) - \\\\text{mitigation costs}_{t,r}$$\n\n    ## Investments and consumption\n\n    This net GDP is then split in a part of investments ($I_t$) and a part of consumption ($C_t$), according to a fixed savings rate ($\\\\text{sr}$):\n\n    $$ I_{t,r} = \\\\text{sr} \\\\cdot \\\\text{GDP}_{\\\\text{net},t,r}, $$\n\n    $$ C_{t,r} = (1 - \\\\text{sr}) \\\\cdot \\\\text{GDP}_{\\\\text{net},t,r}. $$\n\n    ## Capital stock\n\n    The capital stock $K_t$ grows over time according to the investments and the depreciation of the capital stock:\n\n    $$ K_{t,r} = K_{t-1,r} + \\\\Delta t \\\\cdot \\\\frac{\\\\partial K_{t,r}}{\\\\partial t}, $$\n\n    with the change in capital stock calculated by:\n\n    :::mimosa.common.economics.calc_dKdt\n\n    Since this only gives the change in capital stock, we need to add the initial capital stock to get the actual capital stock.\n    This is calculated as a region-dependent multiple of the initial GDP:\n\n    $$ K_{t=0,r} = \\\\text{init_capitalstock_factor}_r \\\\cdot \\\\text{GDP}_{t=0,r}. $$\n\n    The initial capital stock factor is a calibration factor to obtain the initial capital stock. TODO: Source (IMF)\n    ``` plotly\n    {\"file_path\": \"./assets/plots/init_capital_factor.json\"}\n    ```\n\n    ## Parameters defined in this module\n    - <code>init_capitalstock_factor</code>\n    - <code>alpha</code>: Output elasticity of capital. Type: float. Default: 0.3. Min: 0. Max: 1.\n    - <code>dk</code>: Yearly depreciation rate of capital stock. Type: float. Default: 0.05. Min: 0. Max: inf.\n    - <code>sr</code>: Fraction of GDP used for investments. Type: float. Default: 0.21. Min: 0. Max: 1.\n    - <code>ignore_damages</code>: Flag to not take into account the damages in the GDP (but damages are calculated). Type: bool. Default: False.\n\n\n\n    \"\"\"\n    constraints = []\n\n    m.init_capitalstock_factor = Param(m.regions, units=quant.unit(\"currency_unit\"))\n    m.capital_stock = Var(\n        m.t,\n        m.regions,\n        initialize=lambda m, t, r: m.init_capitalstock_factor[r] * m.GDP(m.year(t), r),\n        units=quant.unit(\"currency_unit\"),\n    )\n\n    # Parameters\n    m.alpha = Param(doc=\"::economics.GDP.alpha\")\n    m.dk = Param(doc=\"::economics.GDP.depreciation of capital\")\n    m.sr = Param(doc=\"::economics.GDP.savings rate\")\n\n    m.GDP_gross = Var(\n        m.t,\n        m.regions,\n        initialize=lambda m, t, r: m.GDP(m.year(0), r),\n        units=quant.unit(\"currency_unit\"),\n    )\n    m.GDP_net = Var(\n        m.t,\n        m.regions,\n        units=quant.unit(\"currency_unit\"),\n        initialize=lambda m, t, r: m.GDP(m.year(0), r),\n    )\n    m.investments = Var(m.t, m.regions, units=quant.unit(\"currency_unit\"))\n    m.consumption = Var(m.t, m.regions, units=quant.unit(\"currency_unit\"))\n\n    m.ignore_damages = Param(doc=\"::economics.damages.ignore damages\")\n\n    # Cobb-Douglas, GDP, investments, capital and consumption\n    constraints.extend(\n        [\n            RegionalConstraint(\n                lambda m, t, r: (\n                    m.GDP_gross[t, r]\n                    == economics.calc_GDP(\n                        m.TFP(m.year(t), r),\n                        m.L(m.year(t), r),\n                        soft_min(m.capital_stock[t, r], scale=10),\n                        m.alpha,\n                    )\n                    if t &gt; 0\n                    else Constraint.Skip\n                ),\n                \"GDP_gross\",\n            ),\n            RegionalInitConstraint(\n                lambda m, r: m.GDP_gross[0, r] == m.GDP(m.year(0), r), \"GDP_gross_init\"\n            ),\n            RegionalConstraint(\n                lambda m, t, r: m.GDP_net[t, r]\n                == m.GDP_gross[t, r]\n                * (1 - (m.damage_costs[t, r] if not value(m.ignore_damages) else 0))\n                - m.mitigation_costs[t, r]\n                - m.financial_transfer[t, r],\n                \"GDP_net\",\n            ),\n            RegionalConstraint(\n                lambda m, t, r: m.investments[t, r] == m.sr * m.GDP_net[t, r],\n                \"investments\",\n            ),\n            RegionalConstraint(\n                lambda m, t, r: m.consumption[t, r] == (1 - m.sr) * m.GDP_net[t, r],\n                \"consumption\",\n            ),\n            RegionalConstraint(\n                lambda m, t, r: (\n                    (\n                        m.capital_stock[t, r]\n                        == m.capital_stock[t - 1, r]\n                        + m.dt\n                        * economics.calc_dKdt(\n                            m.capital_stock[t, r], m.dk, m.investments[t, r], m.dt\n                        )\n                    )\n                    if t &gt; 0\n                    else Constraint.Skip\n                ),\n                \"capital_stock\",\n            ),\n            RegionalInitConstraint(\n                lambda m, r: m.capital_stock[0, r]\n                == m.init_capitalstock_factor[r] * m.GDP(m.year(0), r)\n            ),\n        ]\n    )\n\n    return constraints\n</code></pre>"},{"location":"components/emissions/","title":"Emissions and temperature","text":"<p> Back to general structure</p>"},{"location":"components/emissions/#mimosa.components.emissions.get_constraints--regional-global-baseline-and-mitigated-emissions","title":"Regional, global, baseline and mitigated emissions","text":""},{"location":"components/emissions/#mimosa.components.emissions._get_emissions_constraints--parameters-defined-in-this-module","title":"Parameters defined in this module","text":"<ul> <li><code>baseline_carbon_intensity</code>: If true, use baseline carbon intensity to calculate baseline emissions. If false, the SSP baseline emissions are used, regardless of lower GDP.. Type: bool. Default: True.</li> <li><code>cumulative_emissions_trapz</code>: If true, calculate cumulative emissions using trapezoidal interpolation. If false, cum. emissions are simply cum_emissions[t-1] + dt * cum_emissions[t]. This is less accurate, but better for numerical stability. For small dt the  approximation is usually still acceptable.. Type: bool. Default: True.</li> </ul> Source code in <code>mimosa/components/emissions.py</code> <pre><code>def _get_emissions_constraints(m: AbstractModel) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n    ## Parameters defined in this module\n    - <code>baseline_carbon_intensity</code>: If true, use baseline carbon intensity to calculate baseline emissions. If false, the SSP baseline emissions are used, regardless of lower GDP.. Type: bool. Default: True.\n    - <code>cumulative_emissions_trapz</code>: If true, calculate cumulative emissions using trapezoidal interpolation. If false, cum. emissions are simply cum_emissions[t-1] + dt * cum_emissions[t]. This is less accurate, but better for numerical stability. For small dt the  approximation is usually still acceptable.. Type: bool. Default: True.\n    \"\"\"\n\n    constraints = []\n\n    m.regional_emissions = Var(m.t, m.regions, units=quant.unit(\"emissionsrate_unit\"))\n    m.baseline = Var(\n        m.t,\n        m.regions,\n        initialize=lambda m, t, r: m.baseline_emissions(m.year(t), r),\n        units=quant.unit(\"emissionsrate_unit\"),\n    )\n    m.baseline_carbon_intensity = Param(doc=\"::emissions.baseline carbon intensity\")\n\n    m.relative_abatement = Var(\n        m.t,\n        m.regions,\n        initialize=0,\n        bounds=(0, 2.5),\n        units=quant.unit(\"fraction_of_baseline_emissions\"),\n    )\n    m.regional_emission_reduction = Var(\n        m.t, m.regions, units=quant.unit(\"emissionsrate_unit\")\n    )\n    m.cumulative_emissions = Var(m.t, units=quant.unit(\"emissions_unit\"))\n    m.global_emissions = Var(m.t, units=quant.unit(\"emissionsrate_unit\"))\n\n    m.cumulative_emissions_trapz = Param(doc=\"::emissions.cumulative_emissions_trapz\")\n\n    constraints.extend(\n        [\n            # Baseline emissions based on emissions or carbon intensity\n            RegionalConstraint(\n                lambda m, t, r: (\n                    (\n                        m.baseline[t, r]\n                        == m.carbon_intensity(m.year(t), r) * m.GDP_net[t, r]\n                    )\n                    if value(m.baseline_carbon_intensity)\n                    else (m.baseline[t, r] == m.baseline_emissions(m.year(t), r))\n                ),\n                name=\"baseline_emissions\",\n            ),\n            # Regional emissions from baseline and relative abatement\n            RegionalConstraint(\n                lambda m, t, r: (\n                    m.regional_emissions[t, r]\n                    == (1 - m.relative_abatement[t, r])\n                    * (\n                        m.baseline[t, r]\n                        if value(m.baseline_carbon_intensity)\n                        else m.baseline_emissions(m.year(t), r)\n                        # Note: this should simply be m.baseline[t,r], but this is numerically less stable\n                        # than m.baseline_emissions(m.year(t), r) whenever baseline intensity\n                        # is used instead of baseline emissions. In fact, m.baseline_emissions(m.year(t), r)\n                        # is just a fixed number, whereas m.baseline[t,r] is a variable depending on\n                        # GDP.\n                    )\n                    if t &gt; 0\n                    else Constraint.Skip\n                ),\n                \"regional_abatement\",\n            ),\n            RegionalInitConstraint(\n                lambda m, r: m.regional_emissions[0, r]\n                == m.baseline_emissions(m.year(0), r)\n            ),\n            RegionalConstraint(\n                lambda m, t, r: m.regional_emission_reduction[t, r]\n                == m.baseline[t, r] - m.regional_emissions[t, r],\n                \"regional_emission_reduction\",\n            ),\n            # Global emissions (sum from regional emissions)\n            GlobalConstraint(\n                lambda m, t: (\n                    m.global_emissions[t]\n                    == sum(m.regional_emissions[t, r] for r in m.regions)\n                    if t &gt; 0\n                    else Constraint.Skip\n                ),\n                \"global_emissions\",\n            ),\n            GlobalInitConstraint(\n                lambda m: m.global_emissions[0]\n                == sum(m.baseline_emissions(m.year(0), r) for r in m.regions),\n                \"global_emissions_init\",\n            ),\n            # Cumulative global emissions\n            GlobalConstraint(\n                lambda m, t: (\n                    m.cumulative_emissions[t]\n                    == m.cumulative_emissions[t - 1]\n                    + (\n                        (m.dt * (m.global_emissions[t] + m.global_emissions[t - 1]) / 2)\n                        if value(m.cumulative_emissions_trapz)\n                        else (m.dt * m.global_emissions[t])\n                    )\n                    if t &gt; 0\n                    else Constraint.Skip\n                ),\n                \"cumulative_emissions\",\n            ),\n            GlobalInitConstraint(lambda m: m.cumulative_emissions[0] == 0),\n        ]\n    )\n\n    m.emission_relative_cumulative = Var(m.t, initialize=1)\n    constraints.extend(\n        [\n            GlobalConstraint(\n                lambda m, t: (\n                    (\n                        m.emission_relative_cumulative[t]\n                        == m.cumulative_emissions[t]\n                        / m.baseline_cumulative_global(m, m.year(0), m.year(t))\n                    )\n                    if t &gt; 0\n                    else Constraint.Skip\n                ),\n                name=\"relative_cumulative_emissions\",\n            ),\n            GlobalInitConstraint(lambda m: m.emission_relative_cumulative[0] == 1),\n        ]\n    )\n\n    return constraints\n</code></pre>"},{"location":"components/emissions/#mimosa.components.emissions.get_constraints--temperature","title":"Temperature","text":""},{"location":"components/emissions/#mimosa.components.emissions._get_temperature_constraints--parameters-defined-in-this-module","title":"Parameters defined in this module","text":"<ul> <li><code>T0</code>: Temperature in initial year of model run (2020 by default).. Type: quantity. Default: 1.16 delta_degC. Unit: temperature_unit.</li> <li><code>TCRE</code>: Transient Climate Response to CO2 Emissions. Type: quantity. Default: 0.62 delta_degC/(TtCO2). Unit: (temperature_unit)/(emissions_unit).</li> <li><code>temperature_target</code>: Temperature target in 2100 (and beyond). Can also be false, then no temperature target is imposed. Type: quantity. Default: False. Can also be false. Unit: temperature_unit.</li> </ul> Source code in <code>mimosa/components/emissions.py</code> <pre><code>def _get_temperature_constraints(m: AbstractModel) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n\n    ## Parameters defined in this module\n    - <code>T0</code>: Temperature in initial year of model run (2020 by default).. Type: quantity. Default: 1.16 delta_degC. Unit: temperature_unit.\n    - <code>TCRE</code>: Transient Climate Response to CO2 Emissions. Type: quantity. Default: 0.62 delta_degC/(TtCO2). Unit: (temperature_unit)/(emissions_unit).\n    - <code>temperature_target</code>: Temperature target in 2100 (and beyond). Can also be false, then no temperature target is imposed. Type: quantity. Default: False. Can also be false. Unit: temperature_unit.\n    \"\"\"\n\n    constraints = []\n\n    m.T0 = Param(units=quant.unit(\"degC_above_PI\"), doc=\"::temperature.initial\")\n    m.temperature = Var(\n        m.t, initialize=lambda m, t: m.T0, units=quant.unit(\"degC_above_PI\")\n    )\n    m.TCRE = Param(doc=\"::temperature.TCRE\")\n    m.temperature_target = Param(doc=\"::temperature.target\")\n    constraints.extend(\n        [\n            GlobalConstraint(\n                lambda m, t: m.temperature[t]\n                == m.T0 + m.TCRE * m.cumulative_emissions[t],\n                \"temperature\",\n            ),\n            GlobalInitConstraint(lambda m: m.temperature[0] == m.T0),\n            GlobalConstraint(\n                lambda m, t: (\n                    m.temperature[t] &lt;= m.temperature_target\n                    if (m.year(t) &gt;= 2100 and value(m.temperature_target) is not False)\n                    else Constraint.Skip\n                ),\n                name=\"temperature_target\",\n            ),\n        ]\n    )\n\n    m.perc_reversible_damages = Param(doc=\"::economics.damages.percentage reversible\")\n\n    # m.overshoot = Var(m.t, initialize=0)\n    # m.overshootdot = DerivativeVar(m.overshoot, wrt=m.t)\n    # m.netnegative_emissions = Var(m.t)\n    # global_constraints.extend(\n    #     [\n    #         lambda m, t: m.netnegative_emissions[t]\n    #         == m.global_emissions[t] * (1 - tanh(m.global_emissions[t] * 10)) / 2\n    #         if value(m.perc_reversible_damages) &lt; 1\n    #         else Constraint.Skip,\n    #         lambda m, t: m.overshootdot[t]\n    #         == (m.netnegative_emissions[t] if t &lt;= value(m.year2100) and t &gt; 0 else 0)\n    #         if value(m.perc_reversible_damages) &lt; 1\n    #         else Constraint.Skip,\n    #     ]\n    # )\n\n    # global_constraints_init.extend([lambda m: m.overshoot[0] == 0])\n\n    return constraints\n</code></pre>"},{"location":"components/emissions/#mimosa.components.emissions.get_constraints--carbon-budget-inertia-and-other-restrictions","title":"Carbon budget, inertia and other restrictions","text":"Source code in <code>mimosa/components/emissions.py</code> <pre><code>def get_constraints(m: AbstractModel) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n\n    # Regional, global, baseline and mitigated emissions\n    :::mimosa.components.emissions._get_emissions_constraints\n\n    # Temperature\n    :::mimosa.components.emissions._get_temperature_constraints\n\n    # Carbon budget, inertia and other restrictions\n    :::mimosa.components.emissions._get_inertia_and_budget_constraints\n\n    \"\"\"\n    constraints = (\n        _get_emissions_constraints(m)\n        + _get_temperature_constraints(m)\n        + _get_inertia_and_budget_constraints(m)\n    )\n\n    return constraints\n</code></pre>"},{"location":"components/emissions/#mimosa.components.emissions._get_inertia_and_budget_constraints--parameters-defined-in-this-module","title":"Parameters defined in this module","text":"<ul> <li><code>budget</code>: Value of the carbon budget. Example: \"800 GtCO2\" (the unit is important). If set to False, no carbon budget is imposed: this is cost-benefit mode. Default: False.. Type: quantity. Default: False. Can also be false. Unit: emissions_unit.</li> <li><code>inertia_global</code>: Maximum reduction speed, in % of initial emissions (should be negative) Can also be false, then no inertia limit is imposed. Type: float. Default: False. Can also be false. Min: -inf. Max: 0.</li> <li><code>inertia_regional</code>: Maximum reduction speed, in % of initial emissions (should be negative) Can also be false, then no inertia limit is imposed. Type: float. Default: -0.05. Can also be false. Min: -inf. Max: 0.</li> <li><code>global_min_level</code>: Limit on the emission level (globally), mostly used for negative emissions. Can also be false, then no limit is imposed. Type: quantity. Default: -20 GtCO2/yr. Can also be false. Unit: emissionsrate_unit.</li> <li><code>regional_min_level</code>: Limit on the emission level (per region), mostly used for negative emissions. Can also be false, then no limit is imposed. Type: quantity. Default: -10 GtCO2/yr. Can also be false. Unit: emissionsrate_unit.</li> <li><code>no_pos_emissions_after_budget_year</code>: If true, impose net-zero emissions after budget year (2100). Type: bool. Default: True.</li> <li><code>non_increasing_emissions_after_2100</code>: If true, the regional emissions after 2100 are not allowed to climb.. Type: bool. Default: True.</li> </ul> Source code in <code>mimosa/components/emissions.py</code> <pre><code>def _get_inertia_and_budget_constraints(\n    m: AbstractModel,\n) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n\n    ## Parameters defined in this module\n    - <code>budget</code>: Value of the carbon budget. Example: \"800 GtCO2\" (the unit is important). If set to False, no carbon budget is imposed: this is cost-benefit mode. Default: False.. Type: quantity. Default: False. Can also be false. Unit: emissions_unit.\n    - <code>inertia_global</code>: Maximum reduction speed, in % of initial emissions (should be negative) Can also be false, then no inertia limit is imposed. Type: float. Default: False. Can also be false. Min: -inf. Max: 0.\n    - <code>inertia_regional</code>: Maximum reduction speed, in % of initial emissions (should be negative) Can also be false, then no inertia limit is imposed. Type: float. Default: -0.05. Can also be false. Min: -inf. Max: 0.\n    - <code>global_min_level</code>: Limit on the emission level (globally), mostly used for negative emissions. Can also be false, then no limit is imposed. Type: quantity. Default: -20 GtCO2/yr. Can also be false. Unit: emissionsrate_unit.\n    - <code>regional_min_level</code>: Limit on the emission level (per region), mostly used for negative emissions. Can also be false, then no limit is imposed. Type: quantity. Default: -10 GtCO2/yr. Can also be false. Unit: emissionsrate_unit.\n    - <code>no_pos_emissions_after_budget_year</code>: If true, impose net-zero emissions after budget year (2100). Type: bool. Default: True.\n    - <code>non_increasing_emissions_after_2100</code>: If true, the regional emissions after 2100 are not allowed to climb.. Type: bool. Default: True.\n\n    \"\"\"\n\n    constraints = []\n\n    m.budget = Param(doc=\"::emissions.carbonbudget\")\n    m.inertia_global = Param(doc=\"::emissions.inertia.global\")\n    m.inertia_regional = Param(doc=\"::emissions.inertia.regional\")\n    m.global_min_level = Param(doc=\"::emissions.global min level\")\n    m.regional_min_level = Param(doc=\"::emissions.regional min level\")\n    m.no_pos_emissions_after_budget_year = Param(\n        doc=\"::emissions.not positive after budget year\"\n    )\n    m.non_increasing_emissions_after_2100 = Param(\n        doc=\"::emissions.non increasing emissions after 2100\"\n    )\n    constraints.extend(\n        [\n            # Carbon budget constraints:\n            GlobalConstraint(\n                lambda m, t: (\n                    m.cumulative_emissions[t]\n                    - (\n                        m.budget\n                        + (\n                            m.overshoot[t] * (1 - m.perc_reversible_damages)\n                            if value(m.perc_reversible_damages) &lt; 1\n                            else 0\n                        )\n                    )\n                    &lt;= 0\n                    if (m.year(t) &gt;= 2100 and value(m.budget) is not False)\n                    else Constraint.Skip\n                ),\n                name=\"carbon_budget\",\n            ),\n            GlobalConstraint(\n                lambda m, t: (\n                    m.global_emissions[t] &lt;= 0\n                    if (\n                        m.year(t) &gt;= 2100\n                        and value(m.no_pos_emissions_after_budget_year) is True\n                        and value(m.budget) is not False\n                    )\n                    else Constraint.Skip\n                ),\n                name=\"net_zero_after_2100\",\n            ),\n            GlobalConstraint(lambda m, t: m.cumulative_emissions[t] &gt;= 0),\n            # Global and regional inertia constraints:\n            GlobalConstraint(\n                lambda m, t: (\n                    m.global_emissions[t] - m.global_emissions[t - 1]\n                    &gt;= m.dt\n                    * m.inertia_global\n                    * sum(m.baseline_emissions(m.year(0), r) for r in m.regions)\n                    if value(m.inertia_global) is not False and t &gt; 0\n                    else Constraint.Skip\n                ),\n                name=\"global_inertia\",\n            ),\n            RegionalConstraint(\n                lambda m, t, r: (\n                    m.regional_emissions[t, r] - m.regional_emissions[t - 1, r]\n                    &gt;= m.dt * m.inertia_regional * m.baseline_emissions(m.year(0), r)\n                    if value(m.inertia_regional) is not False and t &gt; 0\n                    else Constraint.Skip\n                ),\n                name=\"regional_inertia\",\n            ),\n            RegionalConstraint(\n                lambda m, t, r: (\n                    m.regional_emissions[t, r] - m.regional_emissions[t - 1, r] &lt;= 0\n                    if m.year(t - 1) &gt; 2100\n                    and value(m.non_increasing_emissions_after_2100)\n                    else Constraint.Skip\n                ),\n                name=\"non_increasing_emissions_after_2100\",\n            ),\n            GlobalConstraint(\n                lambda m, t: (\n                    m.global_emissions[t] &gt;= m.global_min_level\n                    if value(m.global_min_level) is not False\n                    else Constraint.Skip\n                ),\n                \"global_min_level\",\n            ),\n            RegionalConstraint(\n                lambda m, t, r: (\n                    m.regional_emissions[t, r] &gt;= m.regional_min_level\n                    if value(m.regional_min_level) is not False\n                    else Constraint.Skip\n                ),\n                \"regional_min_level\",\n            ),\n        ]\n    )\n\n    return constraints\n</code></pre>"},{"location":"components/general/","title":"General structure","text":"<p>The MIMOSA model consists of several sub-modules, called model components. Each component is made up of multiple variables (global or regional), parameters and equations (called constraints).</p>"},{"location":"components/general/#economics","title":"Economics","text":"<p>Cobb-Douglas production function, investments, consumption and capital stock</p> <p> Read more</p>"},{"location":"components/general/#welfare","title":"Welfare","text":"<p>Welfare and the utility function</p> <p> Read more</p>"},{"location":"components/general/#emissions-and-temperature","title":"Emissions and temperature","text":"<ul> <li>Baseline emissions, regional mitigated emissions and cumulative emissions</li> <li>Temperature module</li> <li>Constraints on emissions like inertia</li> </ul> <p> Read more</p>"},{"location":"components/general/#mitigation","title":"Mitigation","text":"<p>Mitigation costs and Marginal Abatement Cost curve</p> <p> Read more</p>"},{"location":"components/general/#sea-level-rise","title":"Sea-level rise","text":"<p>Determines the level of global sea-level rise</p> <p> Read more</p>"},{"location":"components/general/#damages","title":"Damages","text":"<p>Temperature related damages and sea-level rise related damages</p> <p> Read more</p>"},{"location":"components/general/#effort-sharing","title":"Effort-sharing","text":"<p><code>Optional</code> Various effort-sharing regimes to distribute the mitigation (and sometimes damage) costs</p> <p> Read more</p>"},{"location":"components/general/#emission-trading","title":"Emission trading","text":"<p><code>Optional</code> Allows for global trade of emission reductions</p> <p> Read more</p>"},{"location":"components/general/#financial-transfers","title":"Financial transfers","text":"<p><code>Optional</code> Financial transfer schemes like a global damage cost pool</p> <p> Read more</p>"},{"location":"components/general/#mimosa.abstract_model.create_abstract_model--building-the-abstract-model","title":"Building the abstract model","text":"<p>Builds the abstract model for MIMOSA by combining all components. Some components are optional. In the parameters, different variants of some components can be chosen. The components are:</p> <ul> <li><code>damage_module</code>: The damage module to use</li> <li><code>emissiontrade_module</code>: The emission trading module to use</li> <li><code>financialtransfer_module</code>: The financial transfer module to use</li> <li><code>welfare_module</code>: The welfare module to use</li> <li><code>objective_module</code>: The objective module to use</li> </ul> Source code in <code>mimosa/abstract_model.py</code> <pre><code>def create_abstract_model(\n    damage_module: str,\n    emissiontrade_module: str,\n    financialtransfer_module: str,\n    welfare_module: str,\n    objective_module: str,\n) -&gt; AbstractModel:\n    \"\"\"\n    ## Building the abstract model\n\n    Builds the abstract model for MIMOSA by combining all components. Some components are optional. In the\n    parameters, different variants of some components can be chosen. The components are:\n\n    - `damage_module`: The damage module to use\n    - `emissiontrade_module`: The emission trading module to use\n    - `financialtransfer_module`: The financial transfer module to use\n    - `welfare_module`: The welfare module to use\n    - `objective_module`: The objective module to use\n\n    \"\"\"\n    m = AbstractModel()\n\n    ## Constraints\n    # Each constraint will be put in this list,\n    # then added to the model at the end of this file.\n    constraints = []\n\n    ## Time and region\n    m.beginyear = Param()\n    m.dt = Param()\n    m.tf = Param()\n    m.t = Set()\n    m.year = None  # Initialised with concrete instance\n    m.year2100 = Param()\n\n    m.regions = Set(ordered=True)\n\n    ######################\n    # Create data functions\n    # Will be initialised when creating a concrete instance of the model\n    ######################\n\n    m.baseline_emissions = lambda year, region: None\n    m.population = lambda year, region: None\n    m.TFP = lambda year, region: None\n    m.GDP = lambda year, region: None\n    m.carbon_intensity = lambda year, region: None\n\n    def baseline_cumulative(year_start, year_end, region):\n        years = np.linspace(year_start, year_end, 100)\n        return np.trapz(m.baseline_emissions(years, region), x=years)\n\n    m.baseline_cumulative = baseline_cumulative\n    m.baseline_cumulative_global = lambda m, year_start, year_end: sum(\n        baseline_cumulative(year_start, year_end, r) for r in m.regions\n    )\n\n    ######################\n    # Components\n    ######################\n\n    # Emissions and temperature equations\n    constraints.extend(emissions.get_constraints(m))\n\n    # Sea level rise\n    constraints.extend(sealevelrise.get_constraints(m))\n\n    # Damage costs\n    if damage_module == \"RICE2010\":\n        constraints.extend(damages.ad_rice2010.get_constraints(m))\n    elif damage_module == \"WITCH\":\n        constraints.extend(damages.ad_witch.get_constraints(m))\n    elif damage_module == \"RICE2012\":\n        constraints.extend(damages.ad_rice2012.get_constraints(m))\n    elif damage_module == \"COACCH\":\n        constraints.extend(damages.coacch.get_constraints(m))\n    elif damage_module == \"nodamage\":\n        constraints.extend(damages.nodamage.get_constraints(m))\n    else:\n        raise NotImplementedError\n\n    # Abatement costs\n    constraints.extend(mitigation.get_constraints(m))\n\n    # Emission trading\n    if emissiontrade_module == \"notrade\":\n        constraints.extend(emissiontrade.notrade.get_constraints(m))\n    elif emissiontrade_module == \"globalcostpool\":\n        constraints.extend(emissiontrade.globalcostpool.get_constraints(m))\n    elif emissiontrade_module == \"emissiontrade\":\n        constraints.extend(emissiontrade.emissiontrade.get_constraints(m))\n    else:\n        raise NotImplementedError(\n            f\"Emission trading module `{emissiontrade_module}` not implemented\"\n        )\n\n    # Financial transfer\n    if financialtransfer_module == \"notransfer\":\n        constraints.extend(financialtransfer.notransfer.get_constraints(m))\n    elif financialtransfer_module == \"globaldamagepool\":\n        constraints.extend(financialtransfer.globaldamagepool.get_constraints(m))\n    else:\n        raise NotImplementedError(\n            f\"Financial transfer module `{financialtransfer_module}` not implemented\"\n        )\n\n    # Burden sharing regime\n    constraints.extend(burdensharing.get_constraints(m))\n\n    # Cobb-Douglas and economics\n    constraints.extend(cobbdouglas.get_constraints(m))\n\n    # Utility and welfare\n    if welfare_module == \"welfare_loss_minimising\":\n        constraints.extend(welfare.welfare_loss_minimising.get_constraints(m))\n    elif welfare_module == \"cost_minimising\":\n        constraints.extend(welfare.cost_minimising.get_constraints(m))\n    elif welfare_module == \"inequal_aversion_general\":\n        constraints.extend(welfare.inequal_aversion_general.get_constraints(m))\n    else:\n        raise NotImplementedError(f\"Welfare module `{welfare_module}` not implemented\")\n\n    # Objective of optimisation\n    if objective_module == \"utility\":\n        objective_rule, objective_constraints = objective.utility.get_constraints(m)\n    elif objective_module == \"globalcosts\":\n        objective_rule, objective_constraints = objective.globalcosts.get_constraints(m)\n    else:\n        raise NotImplementedError\n\n    constraints.extend(objective_constraints)\n\n    ######################\n    # Add constraints to abstract model\n    ######################\n\n    for constraint in constraints:\n        add_constraint(m, constraint.to_pyomo_constraint(m), constraint.name)\n\n    m.obj = objective_rule\n\n    return m\n</code></pre>"},{"location":"components/welfare/","title":"Welfare","text":"<p> Back to general structure</p>"},{"location":"components/welfare/#welfare-and-utility","title":"Welfare and utility","text":"<p>The optimisation goal of MIMOSA is to maximise discounted welfare or utility<sup>1</sup>. There are three ways to calculate welfare in MIMOSA: welfare-loss-minimising, cost-minimising, and a general inequality aversion setting which is the generalised version of the first two methods.</p> <p>The welfare module can be chosen using the parameter <code>params[\"model\"][\"welfare module\"]</code>.</p> Welfare-loss-minimising <code>default</code>Cost-minimisingGeneral inequality aversion <p>Usage: <pre><code>params = load_params()\nparams[\"model\"][\"welfare module\"] = \"welfare_loss_minimising\"\nmodel = MIMOSA(params)\n</code></pre></p> Welfare-loss-minimising setting <p>In welfare-loss-minimising setting, the utility is first calculated regionally from the per capita consumption. These regional utilities are then summed up to get the global welfare. This means that costs are weighted differently in different regions, depending on the regional per capita consumption. As a consequence, this setting leads to differentiated carbon prices across regions: poorer regions typically will have lower carbon prices than richer regions.</p> Difference with cost-minimising setting <p>In the cost-minimising setting, the regional per capita consumption values are first added up to a global per capita consumption. The utility function is only then applied to this global per capita consumption to obtain global welfare.</p> Equations <p>First, calculate the regional utility using the regional consumption \\(C_{t,r}\\) and population \\(L_{t,r}\\): $$ U_{t,r} = \\text{utility}(C_{t,r}, L_{t,r}) $$</p> <p>Second, the global welfare is calculated as the sum of the regional utility values weighted by population: $$ W_t = \\sum_r L_{t,r} \\cdot U_{t,r} $$</p> Utility function <p>The utility function is a concave function of per-capita consumption, given by:</p> \\[ \\text{utility}(C, L) = \\left( \\left(\\frac{C}{L}\\right)^{1 - \\text{elasmu}} - 1 \\right) \\cdot \\frac{1}{1 - \\text{elasmu}}\\] <p>where \\(C\\) is the consumption and \\(L\\) the population of a region. \\(\\text{elasmu}\\) is the elasticity of marginal utility. A value of \\(\\text{elasmu}\\) close to 1 approaches a logarithmic utility function: </p> Source code in <code>mimosa/components/welfare/utility_fct.py</code> <pre><code>def calc_utility(consumption, population, elasmu):\n    \"\"\"\n    The utility function is a concave function of per-capita consumption, given by:\n\n    $$ \\\\text{utility}(C, L) = \\\\left( \\\\left(\\\\frac{C}{L}\\\\right)^{1 - \\\\text{elasmu}} - 1 \\\\right) \\\\cdot \\\\frac{1}{1 - \\\\text{elasmu}}$$\n\n    where $C$ is the consumption and $L$ the population of a region. $\\\\text{elasmu}$ is the elasticity of marginal utility. A value of $\\\\text{elasmu}$ close to 1 approaches a logarithmic utility function:\n    ``` plotly\n    {\"file_path\": \"./assets/plots/utility_fct.json\"}\n    ```\n\n    \"\"\"\n\n    # Note that the `soft_min` function is used to avoid division by zero\n    return (soft_min(consumption / population) ** (1 - elasmu) - 1) / (1 - elasmu)\n</code></pre> Parameters defined in this module <ul> <li><code>elasmu</code>: Elasticity of marginal utility. Type: float. Default: 1.001. Min: 0.1. Max: 10.</li> </ul> Source code in <code>mimosa/components/welfare/welfare_loss_minimising.py</code> <pre><code>def get_constraints(m: AbstractModel) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n\n    &lt;h3&gt;Welfare-loss-minimising setting&lt;/h3&gt;\n\n    In welfare-loss-minimising setting, the utility is first calculated regionally\n    from the per capita consumption. These regional utilities are then summed up to\n    get the global welfare. This means that costs are weighted differently in different\n    regions, depending on the regional per capita consumption. As a consequence, this\n    setting leads to differentiated carbon prices across regions: poorer regions typically\n    will have lower carbon prices than richer regions.\n\n    ???+ info \"Difference with cost-minimising setting\"\n        In the cost-minimising setting, the regional per capita consumption values\n        are first added up to a global per capita consumption. The utility function\n        is only then applied to this global per capita consumption to obtain global welfare.\n\n    &lt;h3&gt;Equations&lt;/h3&gt;\n\n    First, calculate the regional utility using the regional consumption $C_{t,r}$ and population $L_{t,r}$:\n    $$ U_{t,r} = \\\\text{utility}(C_{t,r}, L_{t,r}) $$\n\n    Second, the global welfare is calculated as the sum of the regional utility values weighted by population:\n    $$ W_t = \\\\sum_r L_{t,r} \\\\cdot U_{t,r} $$\n\n    &lt;h3&gt;Utility function&lt;/h3&gt;\n    :::mimosa.components.welfare.utility_fct.calc_utility\n\n\n    &lt;h3&gt;Parameters defined in this module&lt;/h3&gt;\n    - <code>elasmu</code>: Elasticity of marginal utility. Type: float. Default: 1.001. Min: 0.1. Max: 10.\n\n    \"\"\"\n    constraints = []\n\n    # Parameters\n    m.elasmu = Param(doc=\"::economics.elasmu\")\n\n    m.utility = Var(m.t, m.regions, initialize=0.1)\n    m.yearly_welfare = Var(m.t)\n\n    constraints.extend(\n        [\n            RegionalConstraint(\n                lambda m, t, r: m.utility[t, r]\n                == calc_utility(m.consumption[t, r], m.L(m.year(t), r), m.elasmu),\n                \"utility\",\n            ),\n            GlobalConstraint(\n                lambda m, t: m.yearly_welfare[t]\n                == sum(m.L(m.year(t), r) * m.utility[t, r] for r in m.regions),\n                \"yearly_welfare\",\n            ),\n        ]\n    )\n\n    return constraints\n</code></pre> <p>Usage: <pre><code>params = load_params()\nparams[\"model\"][\"welfare module\"] = \"cost_minimising\"\nmodel = MIMOSA(params)\n</code></pre></p> Cost-minimising setting <p>In cost-minimising setting, the global per-capita consumption is first calculated before applying the utility function. This means that costs are weighted equally across regions, regardless of the regional per capita consumption. As a consequence, this setting leads to uniform carbon prices across regions. This is quantitatively similar to using Negishi weights.</p> Difference with welfare-loss-minimising setting <p>In the welfare-loss-minimising setting, the utility function is applied to the regional per capita consumption values, and the regional utilities are then summed up to get the global welfare. This means that costs (from mitigation or damages) have a larger weight in the final welfare in poorer regions than in richer regions.</p> Equations <p>First, calculate the global consumption \\(C_{t,r}\\) and population \\(L_{t,r}\\):</p> \\[ \\widehat{C}_{t} = \\sum_r C_{t,r}, \\] \\[ \\widehat{L}_{t} = \\sum_r L_{t,r}. \\] <p>These are used to calculate the global utility:</p> \\[ W_t = \\widehat{L}_t \\cdot \\text{utility}\\left( \\widehat{C}_{t}, \\widehat{L}_{t} \\right) \\] Utility function <p>The utility function is a concave function of per-capita consumption, given by:</p> \\[ \\text{utility}(C, L) = \\left( \\left(\\frac{C}{L}\\right)^{1 - \\text{elasmu}} - 1 \\right) \\cdot \\frac{1}{1 - \\text{elasmu}}\\] <p>where \\(C\\) is the consumption and \\(L\\) the population of a region. \\(\\text{elasmu}\\) is the elasticity of marginal utility. A value of \\(\\text{elasmu}\\) close to 1 approaches a logarithmic utility function: </p> Source code in <code>mimosa/components/welfare/utility_fct.py</code> <pre><code>def calc_utility(consumption, population, elasmu):\n    \"\"\"\n    The utility function is a concave function of per-capita consumption, given by:\n\n    $$ \\\\text{utility}(C, L) = \\\\left( \\\\left(\\\\frac{C}{L}\\\\right)^{1 - \\\\text{elasmu}} - 1 \\\\right) \\\\cdot \\\\frac{1}{1 - \\\\text{elasmu}}$$\n\n    where $C$ is the consumption and $L$ the population of a region. $\\\\text{elasmu}$ is the elasticity of marginal utility. A value of $\\\\text{elasmu}$ close to 1 approaches a logarithmic utility function:\n    ``` plotly\n    {\"file_path\": \"./assets/plots/utility_fct.json\"}\n    ```\n\n    \"\"\"\n\n    # Note that the `soft_min` function is used to avoid division by zero\n    return (soft_min(consumption / population) ** (1 - elasmu) - 1) / (1 - elasmu)\n</code></pre> Parameters defined in this module <ul> <li><code>elasmu</code>: Elasticity of marginal utility. Type: float. Default: 1.001. Min: 0.1. Max: 10.</li> </ul> Source code in <code>mimosa/components/welfare/cost_minimising.py</code> <pre><code>def get_constraints(m: AbstractModel) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n\n    &lt;h3&gt;Cost-minimising setting&lt;/h3&gt;\n\n    In cost-minimising setting, the global per-capita consumption is first calculated before\n    applying the utility function. This means that costs are weighted equally across regions,\n    regardless of the regional per capita consumption. As a consequence, this setting leads to\n    uniform carbon prices across regions. This is quantitatively similar to using Negishi weights.\n\n    ???+ info \"Difference with welfare-loss-minimising setting\"\n        In the welfare-loss-minimising setting, the utility function is applied to the regional\n        per capita consumption values, and the regional utilities are then summed up to get the\n        global welfare. This means that costs (from mitigation or damages) have a larger weight in\n        the final welfare in poorer regions than in richer regions.\n\n\n    &lt;h3&gt;Equations&lt;/h3&gt;\n\n    First, calculate the global consumption $C_{t,r}$ and population $L_{t,r}$:\n\n    $$ \\\\widehat{C}_{t} = \\\\sum_r C_{t,r}, $$\n\n    $$ \\\\widehat{L}_{t} = \\\\sum_r L_{t,r}. $$\n\n    These are used to calculate the global utility:\n\n    $$ W_t = \\\\widehat{L}_t \\\\cdot \\\\text{utility}\\\\left( \\\\widehat{C}_{t}, \\\\widehat{L}_{t} \\\\right) $$\n\n    &lt;h3&gt;Utility function&lt;/h3&gt;\n    :::mimosa.components.welfare.utility_fct.calc_utility\n\n\n    &lt;h3&gt;Parameters defined in this module&lt;/h3&gt;\n    - <code>elasmu</code>: Elasticity of marginal utility. Type: float. Default: 1.001. Min: 0.1. Max: 10.\n\n    \"\"\"\n    constraints = []\n\n    # Parameters\n    m.elasmu = Param(doc=\"::economics.elasmu\")\n\n    m.utility = Var(m.t, m.regions, initialize=10)\n    m.yearly_welfare = Var(m.t)\n\n    constraints.extend(\n        [\n            RegionalConstraint(\n                lambda m, t, r: m.utility[t, r]\n                == m.consumption[t, r] / m.L(m.year(t), r),\n                \"utility\",\n            ),\n            GlobalConstraint(\n                lambda m, t: m.yearly_welfare[t]\n                == sum(m.L(m.year(t), r) for r in m.regions)\n                * calc_utility(\n                    sum(m.consumption[t, r] for r in m.regions),\n                    sum(m.L(m.year(t), r) for r in m.regions),\n                    m.elasmu,\n                ),\n                \"yearly_welfare\",\n            ),\n        ]\n    )\n\n    return constraints\n</code></pre> <p>Usage: <pre><code>params = load_params()\nparams[\"model\"][\"welfare module\"] = \"inequal_aversion_general\"\nmodel = MIMOSA(params)\n</code></pre></p> General inequality aversion <p>TODO</p> Parameters defined in this module <ul> <li><code>elasmu</code>: Elasticity of marginal utility. Type: float. Default: 1.001. Min: 0.1. Max: 10.</li> <li>param::inequal_aversion</li> </ul> Source code in <code>mimosa/components/welfare/inequal_aversion_general.py</code> <pre><code>def get_constraints(m: AbstractModel) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n    &lt;h3&gt;General inequality aversion&lt;/h3&gt;\n\n    TODO\n\n    &lt;h3&gt;Parameters defined in this module&lt;/h3&gt;\n    - <code>elasmu</code>: Elasticity of marginal utility. Type: float. Default: 1.001. Min: 0.1. Max: 10.\n    - param::inequal_aversion\n\n    \"\"\"\n    constraints = []\n\n    # Parameters\n    m.elasmu = Param(doc=\"::economics.elasmu\")\n    m.inequal_aversion = Param(doc=\"::economics.inequal_aversion\")\n\n    m.utility = Var(m.t, m.regions, initialize=10)\n    m.yearly_welfare = Var(m.t)\n\n    constraints.extend(\n        [\n            RegionalConstraint(\n                lambda m, t, r: m.utility[t, r]\n                == calc_regional_utility(\n                    m.consumption[t, r], m.L(m.year(t), r), m.inequal_aversion\n                ),\n                \"utility\",\n            ),\n            GlobalConstraint(\n                lambda m, t: m.yearly_welfare[t]\n                == sum(m.L(m.year(t), r) for r in m.regions)\n                * calc_global_utility(\n                    sum(m.utility[t, r] for r in m.regions),\n                    sum(m.L(m.year(t), r) for r in m.regions),\n                    m.elasmu,\n                    m.inequal_aversion,\n                ),\n                \"yearly_welfare\",\n            ),\n        ]\n    )\n\n    return constraints\n</code></pre>"},{"location":"components/welfare/#optimisation-goal-and-discounting","title":"Optimisation goal and discounting","text":"<p>TODO</p> <ol> <li> <p>While the terms welfare and utility can be used interchangeably, we typically refer to utility as the regional utility, and welfare as the global population-weighted utility.\u00a0\u21a9</p> </li> </ol>"}]}