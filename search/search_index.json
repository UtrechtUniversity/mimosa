{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#mimosa-mathematical-integrated-model-for-optimal-and-stylised-assessment","title":"MIMOSA: Mathematical Integrated Model for Optimal and Stylised Assessment","text":"<p>MIMOSA is a recent simple IAM based on FAIR, with 26 regions covering the whole world. It is a relatively simple Cost-Benefit IAM but still covers the relevant technological and socio-economic dynamics. Temperature is a linear function of cumulative CO2 emissions. MIMOSA uses the DICE sea-level rise module. The mitigation costs, population, initial capital stock and baseline GDP and CO2 emissions are regional. The direct regional mitigation costs are calculated as area under the Marginal Abatement Cost (MAC) curve, and have been calibrated to the IPCC AR6 WGIII database.</p>"},{"location":"#general","title":"General","text":"<p>The model is written in the Python optimisation package Pyomo. It is mainly an <code>AbstractModel</code> (object containing all the variables, parameters and constraints, without the actual data values), which is then transformed into a <code>ConcreteModel</code> by putting all the parameter values in it. This <code>ConcreteModel</code> is sent to the solver (IPOPT, an open-source large-scale nonlinear optimisation suite).</p> <p> Schematic overview of the MIMOSA model. From [1].</p>"},{"location":"#how-to-cite","title":"How to cite","text":"<p>When using MIMOSA, please cite [1] (global version) and [2] (regional version).</p>"},{"location":"#references","title":"References","text":"<p>[1]  van der Wijst, KI., Hof, A.F. &amp; van Vuuren, D.P. On the optimality of 2\u00b0C targets and a decomposition of uncertainty. Nature Communications 12, 2575 (2021). https://doi.org/10.1038/s41467-021-22826-5</p> <p>[2]  van der Wijst, KI., Bosello, F., Dasgupta, S. et al. New damage curves and multimodel analysis suggest lower optimal temperature. Nature Climate Change 13, 434\u2013441 (2023). https://doi.org/10.1038/s41558-023-01636-1</p>"},{"location":"extending_mimosa/","title":"Extending MIMOSA","text":"<ul> <li>Adding a variable</li> <li> <p>Adding a parameter</p> </li> <li> <p>Adding a new component (import abstract_model etc)</p> </li> </ul>"},{"location":"installation/","title":"Installing MIMOSA","text":"<p>MIMOSA can be installed using <code>pip</code>: <pre><code>pip install mimosa\n</code></pre></p>"},{"location":"installation/#installing-the-optimisation-engine-ipopt","title":"Installing the optimisation engine IPOPT","text":"<p>Since MIMOSA is an optimisation model, an optimisation engine needs to be specified. This can be installed locally (see With IPOPT installed locally), but an easier way is to use a free cloud-based optimisation service called NEOS.</p> Using the NEOS serverWith IPOPT installed locally <p>The MIMOSA runs can easily be sent to the NEOS server (https://neos-server.org) for remote optimisation. First, on their website, sign up for a free account. You can then run MIMOSA with NEOS enabled by simply providing it with the email address you used to sign up for NEOS:</p> <pre><code>from mimosa import MIMOSA, load_params\n\nparams = load_params()\n\nmodel1 = MIMOSA(params)\nmodel1.solve(use_neos=True, neos_email=\"your.email@email.com\")\nmodel1.save(\"run1\")\n</code></pre> <p>Depending on the MIMOSA parameters chosen and on how busy the NEOS server is, running the model might take a while (typically a couple of minutes).</p> <p>A faster way to run MIMOSA, and which doesn't require an internet connection, is to install the open-source optimisation engine IPOPT locally: <pre><code>conda install -c conda-forge ipopt\n</code></pre> However, this sometimes fails on Windows. To fix it, go to https://www.coin-or.org/download/binary/Ipopt/ and download the latest win64-version. Unzip the files. A subfolder <code>bin</code> should contain the file <code>ipopt.exe</code>. The next step is to add this folder to your PATH environment: Windows &gt; Edit the system environment variables &gt; Environment variables... &gt; Select \"Path\" and click Edit... &gt; Click New and browse to the folder you just unzipped. Make sure to select the <code>bin</code> subfolder as this folder contains the file <code>ipopt.exe</code>.</p> <p>Once IPOPT is installed, MIMOSA can be ran without NEOS: <pre><code>from mimosa import MIMOSA, load_params\n\nparams = load_params()\n\nmodel1 = MIMOSA(params)\nmodel1.solve()  # No NEOS required\nmodel1.save(\"run1\")\n</code></pre></p>"},{"location":"run/","title":"Running MIMOSA","text":""},{"location":"run/#base-run","title":"Base run","text":"<p>A basic run of MIMOSA requires 4 steps: loading the parameters, building the model instance, solving the model and finally saving the output. With this code, the default parameter values are used (see Parameter reference).</p> <pre><code>from mimosa import MIMOSA, load_params\n\nparams = load_params()  # (1)!\n\nmodel1 = MIMOSA(params) # (2)!\nmodel1.solve() # (3)!\n\nmodel1.save(\"run1\") # (4)!\n</code></pre> <ol> <li>Read the default parameters</li> <li>Build the model using the parameters</li> <li>Once the model is built, send the model to the solver.      Note that if you use the NEOS solver, use the syntax <code>model1.solve(use_neos=True, neos_email=\"your.email@email.com\")</code></li> <li>Export the output to the file output/run1.csv</li> </ol>"},{"location":"run/#reading-the-output","title":"Reading the output","text":""},{"location":"run/#changing-parameters","title":"Changing parameters","text":"<p>The default parameters from <code>load_params()</code> are given as a nested dictionary. Every item of this dictionary can be changed. Note that only the values can be changed, it is not possible to add or substract parameters to this dictionary (without Extending MIMOSA).</p>"},{"location":"run/#example-1-carbon-budget","title":"Example 1: carbon budget","text":"<pre><code>from mimosa import MIMOSA, load_params\n\nparams = load_params()\n\nparams[\"emissions\"][\"carbonbudget\"] = \"500 GtCO2\" # (1)!\n\nmodel1 = MIMOSA(params)\nmodel1.solve()\n\nmodel1.save(\"run_example1\")\n</code></pre> <ol> <li>Change the parameter of emissions &gt; carbonbudget to the string \"500 GtCO2\"</li> </ol>"},{"location":"run/#example-2","title":"Example 2:","text":""},{"location":"run/#doing-multiple-runs","title":"Doing multiple runs","text":""},{"location":"components/economics/","title":"Economics","text":""},{"location":"components/economics/#mimosa.components.cobbdouglas.get_constraints--economic-module-and-production-function","title":"Economic module and production function","text":""},{"location":"components/economics/#mimosa.components.cobbdouglas.get_constraints--gross-and-net-gdp","title":"Gross and net GDP","text":"<p>The core of the model is the economic module, detailing how GDP, investments and consumptions vary over time. We use a traditional Cobb-Douglas production function. This means that the gross GDP is calculated by:</p> <p>$$ \\text{GDP}_{\\text{gross},t,r} = \\text{TFP}_{t,r} \\cdot L^{1-\\alpha}_{t,r} \\cdot K^{\\alpha}_{t,r}, $$ with \\(\\text{TFP}\\) the total factor productivity (exogenously calibrated from the baseline SSP scenarios) \\(L\\) the labor (represented by the total population), \\(K\\) the capital stock and \\(\\alpha\\) the share of capital in the production function.</p> Source code in <code>mimosa/common/economics.py</code> <pre><code>def calc_GDP(TFP, L, K, alpha):\n    \"\"\"\n    $$ \\\\text{GDP}_{\\\\text{gross},t,r} = \\\\text{TFP}\\\\_{t,r} \\\\cdot L^{1-\\\\alpha}\\\\_{t,r} \\\\cdot K^{\\\\alpha}\\\\_{t,r}, $$\n    with $\\\\text{TFP}$ the total factor productivity (exogenously calibrated from the baseline SSP scenarios)\n    $L$ the labor (represented by the total population), $K$ the capital stock and $\\\\alpha$ the share of capital in the production function.\n\n    \"\"\"\n    return TFP * L ** (1 - alpha) * K**alpha\n</code></pre> <p>The net GDP is then calculated by subtracting the damages and mitigation costs from the gross GDP. (Note that in MIMOSA, the damages are expressed as a fraction of the gross GDP, whereas the mitigation costs are expressed in absolute terms.)</p> \\[ \\text{GDP}_{\\text{net},t,r} = \\text{GDP}_{\\text{gross},t,r} \\cdot (1 - \\text{damage costs}_{t,r}) - \\text{mitigation costs}_{t,r}\\]"},{"location":"components/economics/#mimosa.components.cobbdouglas.get_constraints--investments-and-consumption","title":"Investments and consumption","text":"<p>This net GDP is then split in a part of investments (\\(I_t\\)) and a part of consumption (\\(C_t\\)), according to a fixed savings rate (\\(\\text{sr}\\)):</p> \\[ I_{t,r} = \\text{sr} \\cdot \\text{GDP}_{\\text{net},t,r}, \\] \\[ C_{t,r} = (1 - \\text{sr}) \\cdot \\text{GDP}_{\\text{net},t,r}. \\]"},{"location":"components/economics/#mimosa.components.cobbdouglas.get_constraints--capital-stock","title":"Capital stock","text":"<p>The capital stock \\(K_t\\) grows over time according to the investments and the depreciation of the capital stock:</p> \\[ K_{t,r} = K_{t-1,r} + \\Delta t \\cdot \\frac{\\partial K_{t,r}}{\\partial t}, \\] <p>with the change in capital stock calculated by:</p> \\[ \\frac{\\partial K_{t,r}}{\\partial t} = \\frac{1}{\\Delta t} \\cdot ((1 - dk)^{\\Delta t}  - 1) \\cdot K_{t,r} + I_{t,r}.\\] Source code in <code>mimosa/common/economics.py</code> <pre><code>def calc_dKdt(K, dk, I, dt):\n    \"\"\"\n    $$ \\\\frac{\\\\partial K_{t,r}}{\\\\partial t} = \\\\frac{1}{\\\\Delta t} \\\\cdot ((1 - dk)^{\\\\Delta t}  - 1) \\\\cdot K_{t,r} + I_{t,r}.$$\n    \"\"\"\n    return ((1 - dk) ** dt - 1) / dt * K + I\n</code></pre> <p>Since this only gives the change in capital stock, we need to add the initial capital stock to get the actual capital stock. This is calculated as a region-dependent multiple of the initial GDP:</p> \\[ K_{t=0,r} = \\text{init_capitalstock_factor}_r \\cdot \\text{GDP}_{t=0,r}. \\] Todo <p>Add a graph of the initial capital stock factors.</p>"},{"location":"components/economics/#mimosa.components.cobbdouglas.get_constraints--parameters-defined-in-this-module","title":"Parameters defined in this module","text":"<ul> <li><code>init_capitalstock_factor</code></li> <li><code>alpha</code>: Output elasticity of capital. Type: float. Default: 0.3. Min: 0. Max: 1.</li> <li><code>dk</code>: Yearly depreciation rate of capital stock. Type: float. Default: 0.05. Min: 0. Max: inf.</li> <li><code>sr</code>: Fraction of GDP used for investments. Type: float. Default: 0.21. Min: 0. Max: 1.</li> <li><code>ignore_damages</code>: Flag to not take into account the damages in the GDP (but damages are calculated). Type: bool. Default: False.</li> </ul> Source code in <code>mimosa/components/cobbdouglas.py</code> <pre><code>def get_constraints(m: AbstractModel) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n    # Economic module and production function\n\n    ## Gross and net GDP\n\n    The core of the model is the economic module, detailing how GDP, investments and\n    consumptions vary over time. We use a traditional Cobb-Douglas production function. This means\n    that the gross GDP is calculated by:\n\n    :::mimosa.common.economics.calc_GDP\n\n    The net GDP is then calculated by subtracting the damages and\n    mitigation costs from the gross GDP. *(Note that in MIMOSA, the damages are expressed as a fraction of the gross GDP,\n    whereas the mitigation costs are expressed in absolute terms.)*\n\n    $$ \\\\text{GDP}_{\\\\text{net},t,r} = \\\\text{GDP}_{\\\\text{gross},t,r} \\\\cdot (1 - \\\\text{damage costs}_{t,r}) - \\\\text{mitigation costs}_{t,r}$$\n\n    ## Investments and consumption\n\n    This net GDP is then split in a part of investments ($I_t$) and a part of consumption ($C_t$), according to a fixed savings rate ($\\\\text{sr}$):\n\n    $$ I_{t,r} = \\\\text{sr} \\\\cdot \\\\text{GDP}_{\\\\text{net},t,r}, $$\n\n    $$ C_{t,r} = (1 - \\\\text{sr}) \\\\cdot \\\\text{GDP}_{\\\\text{net},t,r}. $$\n\n    ## Capital stock\n\n    The capital stock $K_t$ grows over time according to the investments and the depreciation of the capital stock:\n\n    $$ K_{t,r} = K_{t-1,r} + \\\\Delta t \\\\cdot \\\\frac{\\\\partial K_{t,r}}{\\\\partial t}, $$\n\n    with the change in capital stock calculated by:\n\n    :::mimosa.common.economics.calc_dKdt\n\n    Since this only gives the change in capital stock, we need to add the initial capital stock to get the actual capital stock.\n    This is calculated as a region-dependent multiple of the initial GDP:\n\n    $$ K_{t=0,r} = \\\\text{init_capitalstock_factor}_r \\\\cdot \\\\text{GDP}_{t=0,r}. $$\n\n    ??? info \"Todo\"\n        Add a graph of the initial capital stock factors.\n\n    ## Parameters defined in this module\n    - <code>init_capitalstock_factor</code>\n    - <code>alpha</code>: Output elasticity of capital. Type: float. Default: 0.3. Min: 0. Max: 1.\n    - <code>dk</code>: Yearly depreciation rate of capital stock. Type: float. Default: 0.05. Min: 0. Max: inf.\n    - <code>sr</code>: Fraction of GDP used for investments. Type: float. Default: 0.21. Min: 0. Max: 1.\n    - <code>ignore_damages</code>: Flag to not take into account the damages in the GDP (but damages are calculated). Type: bool. Default: False.\n\n\n\n    \"\"\"\n    constraints = []\n\n    m.init_capitalstock_factor = Param(m.regions, units=quant.unit(\"currency_unit\"))\n    m.capital_stock = Var(\n        m.t,\n        m.regions,\n        initialize=lambda m, t, r: m.init_capitalstock_factor[r] * m.GDP(m.year(t), r),\n        units=quant.unit(\"currency_unit\"),\n    )\n\n    # Parameters\n    m.alpha = Param(doc=\"::economics.GDP.alpha\")\n    m.dk = Param(doc=\"::economics.GDP.depreciation of capital\")\n    m.sr = Param(doc=\"::economics.GDP.savings rate\")\n\n    m.GDP_gross = Var(\n        m.t,\n        m.regions,\n        initialize=lambda m, t, r: m.GDP(m.year(0), r),\n        units=quant.unit(\"currency_unit\"),\n    )\n    m.GDP_net = Var(\n        m.t,\n        m.regions,\n        units=quant.unit(\"currency_unit\"),\n        initialize=lambda m, t, r: m.GDP(m.year(0), r),\n    )\n    m.investments = Var(m.t, m.regions, units=quant.unit(\"currency_unit\"))\n    m.consumption = Var(m.t, m.regions, units=quant.unit(\"currency_unit\"))\n\n    m.ignore_damages = Param(doc=\"::economics.damages.ignore damages\")\n\n    # Cobb-Douglas, GDP, investments, capital and consumption\n    constraints.extend(\n        [\n            RegionalConstraint(\n                lambda m, t, r: (\n                    m.GDP_gross[t, r]\n                    == economics.calc_GDP(\n                        m.TFP(m.year(t), r),\n                        m.L(m.year(t), r),\n                        soft_min(m.capital_stock[t, r], scale=10),\n                        m.alpha,\n                    )\n                    if t &gt; 0\n                    else Constraint.Skip\n                ),\n                \"GDP_gross\",\n            ),\n            RegionalInitConstraint(\n                lambda m, r: m.GDP_gross[0, r] == m.GDP(m.year(0), r), \"GDP_gross_init\"\n            ),\n            RegionalConstraint(\n                lambda m, t, r: m.GDP_net[t, r]\n                == m.GDP_gross[t, r]\n                * (1 - (m.damage_costs[t, r] if not value(m.ignore_damages) else 0))\n                - m.mitigation_costs[t, r]\n                - m.financial_transfer[t, r],\n                \"GDP_net\",\n            ),\n            RegionalConstraint(\n                lambda m, t, r: m.investments[t, r] == m.sr * m.GDP_net[t, r],\n                \"investments\",\n            ),\n            RegionalConstraint(\n                lambda m, t, r: m.consumption[t, r] == (1 - m.sr) * m.GDP_net[t, r],\n                \"consumption\",\n            ),\n            RegionalConstraint(\n                lambda m, t, r: (\n                    (\n                        m.capital_stock[t, r]\n                        == m.capital_stock[t - 1, r]\n                        + m.dt\n                        * economics.calc_dKdt(\n                            m.capital_stock[t, r], m.dk, m.investments[t, r], m.dt\n                        )\n                    )\n                    if t &gt; 0\n                    else Constraint.Skip\n                ),\n                \"capital_stock\",\n            ),\n            RegionalInitConstraint(\n                lambda m, r: m.capital_stock[0, r]\n                == m.init_capitalstock_factor[r] * m.GDP(m.year(0), r)\n            ),\n        ]\n    )\n\n    return constraints\n</code></pre>"},{"location":"components/emissions/","title":"Emissions","text":""},{"location":"components/emissions/#mimosa.components.emissions.get_constraints--emissions-and-temperature","title":"Emissions and temperature","text":""},{"location":"components/emissions/#mimosa.components.emissions.get_constraints--parameters-defined-in-this-module","title":"Parameters defined in this module","text":"<ul> <li><code>baseline_carbon_intensity</code>: If true, use baseline carbon intensity to calculate baseline emissions. If false, the SSP baseline emissions are used, regardless of lower GDP.. Type: bool. Default: True.</li> <li><code>cumulative_emissions_trapz</code>: If true, calculate cumulative emissions using trapezoidal interpolation. If false, cum. emissions are simply cum_emissions[t-1] + dt * cum_emissions[t]. This is less accurate, but better for numerical stability. For small dt the  approximation is usually still acceptable.. Type: bool. Default: True.</li> </ul> Source code in <code>mimosa/components/emissions.py</code> <pre><code>def get_constraints(m: AbstractModel) -&gt; Sequence[GeneralConstraint]:\n    \"\"\"\n    # Emissions and temperature\n\n    ## Parameters defined in this module\n    - <code>baseline_carbon_intensity</code>: If true, use baseline carbon intensity to calculate baseline emissions. If false, the SSP baseline emissions are used, regardless of lower GDP.. Type: bool. Default: True.\n    - <code>cumulative_emissions_trapz</code>: If true, calculate cumulative emissions using trapezoidal interpolation. If false, cum. emissions are simply cum_emissions[t-1] + dt * cum_emissions[t]. This is less accurate, but better for numerical stability. For small dt the  approximation is usually still acceptable.. Type: bool. Default: True.\n\n\n    \"\"\"\n    constraints = []\n\n    m.regional_emissions = Var(m.t, m.regions, units=quant.unit(\"emissionsrate_unit\"))\n    m.baseline = Var(\n        m.t,\n        m.regions,\n        initialize=lambda m, t, r: m.baseline_emissions(m.year(t), r),\n        units=quant.unit(\"emissionsrate_unit\"),\n    )\n    m.baseline_carbon_intensity = Param(doc=\"::emissions.baseline carbon intensity\")\n\n    m.relative_abatement = Var(\n        m.t,\n        m.regions,\n        initialize=0,\n        bounds=(0, 2.5),\n        units=quant.unit(\"fraction_of_baseline_emissions\"),\n    )\n    m.regional_emission_reduction = Var(\n        m.t, m.regions, units=quant.unit(\"emissionsrate_unit\")\n    )\n    m.cumulative_emissions = Var(m.t, units=quant.unit(\"emissions_unit\"))\n    m.global_emissions = Var(m.t, units=quant.unit(\"emissionsrate_unit\"))\n\n    m.cumulative_emissions_trapz = Param(doc=\"::emissions.cumulative_emissions_trapz\")\n\n    constraints.extend(\n        [\n            # Baseline emissions based on emissions or carbon intensity\n            RegionalConstraint(\n                lambda m, t, r: (\n                    (\n                        m.baseline[t, r]\n                        == m.carbon_intensity(m.year(t), r) * m.GDP_net[t, r]\n                    )\n                    if value(m.baseline_carbon_intensity)\n                    else (m.baseline[t, r] == m.baseline_emissions(m.year(t), r))\n                ),\n                name=\"baseline_emissions\",\n            ),\n            # Regional emissions from baseline and relative abatement\n            RegionalConstraint(\n                lambda m, t, r: (\n                    m.regional_emissions[t, r]\n                    == (1 - m.relative_abatement[t, r])\n                    * (\n                        m.baseline[t, r]\n                        if value(m.baseline_carbon_intensity)\n                        else m.baseline_emissions(m.year(t), r)\n                        # Note: this should simply be m.baseline[t,r], but this is numerically less stable\n                        # than m.baseline_emissions(m.year(t), r) whenever baseline intensity\n                        # is used instead of baseline emissions. In fact, m.baseline_emissions(m.year(t), r)\n                        # is just a fixed number, whereas m.baseline[t,r] is a variable depending on\n                        # GDP.\n                    )\n                    if t &gt; 0\n                    else Constraint.Skip\n                ),\n                \"regional_abatement\",\n            ),\n            RegionalInitConstraint(\n                lambda m, r: m.regional_emissions[0, r]\n                == m.baseline_emissions(m.year(0), r)\n            ),\n            RegionalConstraint(\n                lambda m, t, r: m.regional_emission_reduction[t, r]\n                == m.baseline[t, r] - m.regional_emissions[t, r],\n                \"regional_emission_reduction\",\n            ),\n            # Global emissions (sum from regional emissions)\n            GlobalConstraint(\n                lambda m, t: (\n                    m.global_emissions[t]\n                    == sum(m.regional_emissions[t, r] for r in m.regions)\n                    if t &gt; 0\n                    else Constraint.Skip\n                ),\n                \"global_emissions\",\n            ),\n            GlobalInitConstraint(\n                lambda m: m.global_emissions[0]\n                == sum(m.baseline_emissions(m.year(0), r) for r in m.regions),\n                \"global_emissions_init\",\n            ),\n            # Cumulative global emissions\n            GlobalConstraint(\n                lambda m, t: (\n                    m.cumulative_emissions[t]\n                    == m.cumulative_emissions[t - 1]\n                    + (\n                        (m.dt * (m.global_emissions[t] + m.global_emissions[t - 1]) / 2)\n                        if value(m.cumulative_emissions_trapz)\n                        else (m.dt * m.global_emissions[t])\n                    )\n                    if t &gt; 0\n                    else Constraint.Skip\n                ),\n                \"cumulative_emissions\",\n            ),\n            GlobalInitConstraint(lambda m: m.cumulative_emissions[0] == 0),\n        ]\n    )\n\n    m.T0 = Param(units=quant.unit(\"degC_above_PI\"), doc=\"::temperature.initial\")\n    m.temperature = Var(\n        m.t, initialize=lambda m, t: m.T0, units=quant.unit(\"degC_above_PI\")\n    )\n    m.TCRE = Param(doc=\"::temperature.TCRE\")\n    m.temperature_target = Param(doc=\"::temperature.target\")\n    constraints.extend(\n        [\n            GlobalConstraint(\n                lambda m, t: m.temperature[t]\n                == m.T0 + m.TCRE * m.cumulative_emissions[t],\n                \"temperature\",\n            ),\n            GlobalInitConstraint(lambda m: m.temperature[0] == m.T0),\n            GlobalConstraint(\n                lambda m, t: (\n                    m.temperature[t] &lt;= m.temperature_target\n                    if (m.year(t) &gt;= 2100 and value(m.temperature_target) is not False)\n                    else Constraint.Skip\n                ),\n                name=\"temperature_target\",\n            ),\n        ]\n    )\n\n    m.perc_reversible_damages = Param(doc=\"::economics.damages.percentage reversible\")\n\n    # m.overshoot = Var(m.t, initialize=0)\n    # m.overshootdot = DerivativeVar(m.overshoot, wrt=m.t)\n    # m.netnegative_emissions = Var(m.t)\n    # global_constraints.extend(\n    #     [\n    #         lambda m, t: m.netnegative_emissions[t]\n    #         == m.global_emissions[t] * (1 - tanh(m.global_emissions[t] * 10)) / 2\n    #         if value(m.perc_reversible_damages) &lt; 1\n    #         else Constraint.Skip,\n    #         lambda m, t: m.overshootdot[t]\n    #         == (m.netnegative_emissions[t] if t &lt;= value(m.year2100) and t &gt; 0 else 0)\n    #         if value(m.perc_reversible_damages) &lt; 1\n    #         else Constraint.Skip,\n    #     ]\n    # )\n\n    # global_constraints_init.extend([lambda m: m.overshoot[0] == 0])\n\n    # Emission constraints\n\n    m.budget = Param(doc=\"::emissions.carbonbudget\")\n    m.inertia_global = Param(doc=\"::emissions.inertia.global\")\n    m.inertia_regional = Param(doc=\"::emissions.inertia.regional\")\n    m.global_min_level = Param(doc=\"::emissions.global min level\")\n    m.regional_min_level = Param(doc=\"::emissions.regional min level\")\n    m.no_pos_emissions_after_budget_year = Param(\n        doc=\"::emissions.not positive after budget year\"\n    )\n    m.non_increasing_emissions_after_2100 = Param(\n        doc=\"::emissions.non increasing emissions after 2100\"\n    )\n    constraints.extend(\n        [\n            # Carbon budget constraints:\n            GlobalConstraint(\n                lambda m, t: (\n                    m.cumulative_emissions[t]\n                    - (\n                        m.budget\n                        + (\n                            m.overshoot[t] * (1 - m.perc_reversible_damages)\n                            if value(m.perc_reversible_damages) &lt; 1\n                            else 0\n                        )\n                    )\n                    &lt;= 0\n                    if (m.year(t) &gt;= 2100 and value(m.budget) is not False)\n                    else Constraint.Skip\n                ),\n                name=\"carbon_budget\",\n            ),\n            GlobalConstraint(\n                lambda m, t: (\n                    m.global_emissions[t] &lt;= 0\n                    if (\n                        m.year(t) &gt;= 2100\n                        and value(m.no_pos_emissions_after_budget_year) is True\n                        and value(m.budget) is not False\n                    )\n                    else Constraint.Skip\n                ),\n                name=\"net_zero_after_2100\",\n            ),\n            GlobalConstraint(lambda m, t: m.cumulative_emissions[t] &gt;= 0),\n            # Global and regional inertia constraints:\n            GlobalConstraint(\n                lambda m, t: (\n                    m.global_emissions[t] - m.global_emissions[t - 1]\n                    &gt;= m.dt\n                    * m.inertia_global\n                    * sum(m.baseline_emissions(m.year(0), r) for r in m.regions)\n                    if value(m.inertia_global) is not False and t &gt; 0\n                    else Constraint.Skip\n                ),\n                name=\"global_inertia\",\n            ),\n            RegionalConstraint(\n                lambda m, t, r: (\n                    m.regional_emissions[t, r] - m.regional_emissions[t - 1, r]\n                    &gt;= m.dt * m.inertia_regional * m.baseline_emissions(m.year(0), r)\n                    if value(m.inertia_regional) is not False and t &gt; 0\n                    else Constraint.Skip\n                ),\n                name=\"regional_inertia\",\n            ),\n            RegionalConstraint(\n                lambda m, t, r: (\n                    m.regional_emissions[t, r] - m.regional_emissions[t - 1, r] &lt;= 0\n                    if m.year(t - 1) &gt; 2100\n                    and value(m.non_increasing_emissions_after_2100)\n                    else Constraint.Skip\n                ),\n                name=\"non_increasing_emissions_after_2100\",\n            ),\n            GlobalConstraint(\n                lambda m, t: (\n                    m.global_emissions[t] &gt;= m.global_min_level\n                    if value(m.global_min_level) is not False\n                    else Constraint.Skip\n                ),\n                \"global_min_level\",\n            ),\n            RegionalConstraint(\n                lambda m, t, r: (\n                    m.regional_emissions[t, r] &gt;= m.regional_min_level\n                    if value(m.regional_min_level) is not False\n                    else Constraint.Skip\n                ),\n                \"regional_min_level\",\n            ),\n        ]\n    )\n\n    m.emission_relative_cumulative = Var(m.t, initialize=1)\n    constraints.extend(\n        [\n            GlobalConstraint(\n                lambda m, t: (\n                    (\n                        m.emission_relative_cumulative[t]\n                        == m.cumulative_emissions[t]\n                        / m.baseline_cumulative_global(m, m.year(0), m.year(t))\n                    )\n                    if t &gt; 0\n                    else Constraint.Skip\n                ),\n                name=\"relative_cumulative_emissions\",\n            ),\n            GlobalInitConstraint(lambda m: m.emission_relative_cumulative[0] == 1),\n        ]\n    )\n\n    return constraints\n</code></pre>"}]}